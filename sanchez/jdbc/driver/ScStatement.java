/*
 * @(#)ScStatement.java	1.1 99/09/29
 *
 * @version     1.0  Spet. 28 1999
 * @author      Quansheng Jia
 * @see         ^ScPreparedStatement, ScCallableStatement
 *
 */
package sanchez.jdbc.driver;

/**
 * <P>The object used for executing a static SQL statement
 * and obtaining the results produced by it.
 *
 * <P>Only one ResultSet per Statement can be open at any point in
 * time. Therefore, if the reading of one ResultSet is interleaved
 * with the reading of another, each must have been generated by
 * different Statements. All statement <code>execute</code> methods implicitly
 * close a statment's current ResultSet if an open one exists.
 *
 * @see Connection#createStatement
 * @see ResultSet
 */

import java.io.Serializable;
import java.sql.*;
import java.util.Enumeration;
import java.util.Hashtable;
import java.util.StringTokenizer;
import java.util.Vector;

import sanchez.jdbc.dbaccess.*;
import sanchez.utils.ScMatrix;
import sanchez.him_pa.utils.ScMSQLFormat;
import sanchez.him_pa.utils.ScStringTokenizer;

public class ScStatement implements Statement, Serializable, Cloneable {
    transient protected ScConnection connection;
    SQLWarning warnings;
    private int iQueryTimeout = 0;
    private static int EXECUTE_FAILED = -3;
    //parameters for resultSet
    public int i_iCurrentRow = 0;
    public ScMatrix cells = new ScMatrix();
    public Hashtable i_ahHash = new Hashtable();
    public int i_iTotalRows = 0;
    public boolean gotLastBatch = true;
    public int maxRows = 10000;
    public String[][] description;
    public Object[][] copyDesc;
    public int resultSetType = ResultSet.TYPE_SCROLL_INSENSITIVE;
    public int resultSetConcurrency = ResultSet.CONCUR_READ_ONLY;
    protected int autoGeneratedKeysOption = Statement.NO_GENERATED_KEYS;

    /* MKT - 07/14/2004
     * 1 MB Changes
     */
    protected int maxFieldSize = 1048575;//32000;
    protected int rowCount;
    protected boolean closed;
    protected ScJdbcResultSet lastRs;
    protected int fetchRow;

    protected ScDBStatement dBStatement;
    protected ScDBAccess i_dDbAccess;
    protected Vector i_batchSql = new Vector();

    //for EFD setting
    int efdJulianDate = 0;
    int prepare = 0;

    int resHoldabilty = ResultSet.CLOSE_CURSORS_AT_COMMIT;

    /**
     * Statement getFetchDirection returning ResultSet getFetchDirection()
     * which is initialized in the execute methods. The call on the method
     * if done before any execute method call throws exception
     */
    int default_fetch_direction = ResultSet.FETCH_FORWARD;

    /**
     * No Argument constructor
     * @throws SQLException
     */
    public ScStatement()
            throws SQLException {
    }

    /**
     * Constructs a ScStatement object using a defined ScConnection
     * @param cConnection The Connection to be used 
     * @throws SQLException if a databse access error occurs
     */
    public ScStatement(ScConnection cConnection)
            throws SQLException {
        rowCount = -1;
        closed = false;
        connection = cConnection;
        i_dDbAccess = cConnection.i_dDbAccess;
        fetchRow = i_dDbAccess.getDefaultPrefetch();
    }

    /**
     * Constructs a ScStatement object using a defined ScConnection, resultsetType and resultSetConcurrency  
     * @param cConnection The Connection to be used 
     * @param resultSetType The resultSetType to be used
     * @param resultSetConcurrency The resultSetConcurrency to be used
     * @throws SQLException
     */
    public ScStatement(ScConnection cConnection, int resultSetType, int resultSetConcurrency)
            throws SQLException {
        this.resultSetType = resultSetType;
        this.resultSetConcurrency = resultSetConcurrency;

        if (resultSetType != ResultSet.TYPE_SCROLL_INSENSITIVE && resultSetType != ResultSet.TYPE_FORWARD_ONLY) {
            ScDBError.check_error(-54, Integer.toString(resultSetType));
            return;
        }

        if ((resultSetConcurrency != ResultSet.CONCUR_READ_ONLY) && (resultSetConcurrency != ResultSet.CONCUR_UPDATABLE)) {
            ScDBError.check_error(-55, Integer.toString(resultSetConcurrency));
            return;
        }

        rowCount = -1;
        closed = false;
        connection = cConnection;
        i_dDbAccess = cConnection.i_dDbAccess;
        fetchRow = i_dDbAccess.getDefaultPrefetch();

        this.resultSetType = resultSetType;
        this.resultSetConcurrency = resultSetConcurrency;
    }

    protected ScStatement(ScConnection cConnection, int resultSetType, int resultSetConcurrency, int resultSetHoldability)
            throws SQLException {
        this(cConnection, resultSetType, resultSetConcurrency);
        this.resHoldabilty = resultSetHoldability;
    }

    /**
     * Executes a SQL statement that returns a single ResultSet.
     *
     * @param sql typically this is a static SQL SELECT statement
     * @return a ResultSet that contains the data produced by the
     * query; never null 
     * @exception SQLException if a database access error occurs
     */
    /*
     * Closed Statement were allowing operation. Additional
     * check incorporated to check for already closed Statement
     *
     */
    public ResultSet executeQuery(String sSqlQuery) throws SQLException {
        connection.log("Statement.executeQuery(" + sSqlQuery + ")");
        rowCount = -1;
        ini();
        try {
            if (closed) {
                ScDBError.check_error(-9, "");
            }

            dBStatement = i_dDbAccess.open(sSqlQuery, fetchRow);
            i_dDbAccess.setQueryTimeout(iQueryTimeout);
            int row = i_dDbAccess.fetch(dBStatement);

            try {
                if (((ScMsqlQueryStatement) dBStatement).getSqlStatus().equals("01500")) gotLastBatch = true;
            } catch (Exception e) {
                //on mutithreads testing,  java.lang.NullPointerException in this line SELDOM for unknown reason
                //resubmit statement to make up, a tempaeray solution
                dBStatement = i_dDbAccess.open(sSqlQuery, fetchRow);
                row = i_dDbAccess.fetch(dBStatement);
                if (((ScMsqlQueryStatement) dBStatement).getSqlStatus().equals("01500")) gotLastBatch = true;
            }
            firstFetch(dBStatement);

            //08-21-2003
            Hashtable htMeda = asClearUp(sSqlQuery);
            if (htMeda.size() > 0)
                i_ahHash = htMeda;
            //08-21-2003

            lastRs = new ScJdbcResultSet(connection, this);
            return lastRs;
        } catch (Exception e) {
            ScDBError.check_error(e);
            return null;
        }
    }

    /**
     * Executes an SQL INSERT, UPDATE or DELETE statement. In addition,
     * SQL statements that return nothing, such as SQL DDL statements,
     * can be executed.
     *
     * @param sql a SQL INSERT, UPDATE or DELETE statement or a SQL
     * statement that returns nothing
     * @return either the row count for INSERT, UPDATE or DELETE or 0
     * for SQL statements that return nothing
     * @exception SQLException if a database access error occurs
     */
    /*
     * Closed Statement were allowing operation. Additional
     * check incorporated to check for already closed Statement
     *
     * executeUpdate allowed select query. Additional
     * check incorporated to block select and open
     *
     */
    public int executeUpdate(String sDDLStatement) throws SQLException {
        connection.log("Statement.executeUpdate(" + sDDLStatement + ")");
        if (closed) {
            ScDBError.check_error(-9, "");
        }
        ini();
        dBStatement = new ScMsqlDDLStatement(sDDLStatement);
        if (efdJulianDate > 0) ((ScMsqlDDLStatement) dBStatement).setEFD(efdJulianDate);

        try {
            if (connection.i_bAutoCommit) {
                if (getSqlKind(sDDLStatement) == 0)
                    ScDBError.check_error(-59, "invalid SQL in executeUpdate command ");
                rowCount = i_dDbAccess.executeUpdate(dBStatement);
                return rowCount;
            } else {
                sendFence((ScMsqlDDLStatement) dBStatement);
                return 1;
            }
        } catch (Exception e) {
            ScDBError.check_error(e);
            return 0;
        }
    }

    /**
     * Releases this <code>Statement</code> object's database
     * and JDBC resources immediately instead of waiting for
     * this to happen when it is automatically closed.
     * It is generally good practice to release resources as soon as
     * you are finished with them to avoid tying up database
     * resources.
     * <P><B>Note:</B> A Statement is automatically closed when it is
     * garbage collected. When a Statement is closed, its current
     * ResultSet, if one exists, is also closed.  
     *
     * @exception SQLException if a database access error occurs
     */
    /*
     * Closed Statement were allowing operation. Additional
     * check incorporated to check for already closed Statement
     *
     */
    public void close() throws SQLException {
        try {
            if (closed) {
                ScDBError.check_error(-9, "");
            }
            closed = true;
            cells = null;
            copyDesc = null;
            dBStatement = null;
            description = null;
            i_ahHash = null;
            connection.i_hStatementTable.remove(this);
            this.finalize();
        } catch (Throwable e) {
        }
    }

    /**
     * This method cleans up client-side resources.
     */
    protected void finalize() throws Throwable {
        cells = null;
        dBStatement = null;
        copyDesc = null;
        super.finalize();
    }
    //----------------------------------------------------------------------

    /**
     * Returns the maximum number of bytes allowed
     * for any column value. 
     * This limit is the maximum number of bytes that can be
     * returned for any column value.
     * The limit applies only to BINARY,
     * VARBINARY, LONGVARBINARY, CHAR, VARCHAR, and LONGVARCHAR
     * columns.  If the limit is exceeded, the excess data is silently
     * discarded.
     *
     * @return the current max column size limit; zero means unlimited 
     * @exception SQLException if a database access error occurs
     * @history thoniyim 07/14/2003
     * 	1 MB Changes
     */
    public int getMaxFieldSize() throws SQLException {
        connection.log("Statement.getMaxFieldSize");
        return 1048575;//32000;
    }

    /**
     * Sets the limit for the maximum number of bytes in a column to
     * the given number of bytes.  This is the maximum number of bytes
     * that can be returned for any column value.  This limit applies
     * only to BINARY, VARBINARY, LONGVARBINARY, CHAR, VARCHAR, and
     * LONGVARCHAR fields.  If the limit is exceeded, the excess data
     * is silently discarded. For maximum portability, use values
     * greater than 256.
     *
     * @param max the new max column size limit; zero means unlimited 
     * @exception SQLException if a database access error occurs
     * @history thoniyilmk - 07/15/2004
     * 	As the field size is 1MB change the parameter from int to long
     */
    /*
     * Statement setMaxFieldSize did not have a check for invalid Max File Size.
     */
    public void setMaxFieldSize(int max) throws SQLException {
        connection.log("Statement.setMaxFieldSize");
        if (max < 0)
            ScDBError.check_error(-61, "" + max);
        maxFieldSize = max;
    }

    /**
     * Retrieves the maximum number of rows that a
     * ResultSet can contain.  If the limit is exceeded, the excess
     * rows are silently dropped.
     *
     * @return the current max row limit; zero means unlimited
     * @exception SQLException if a database access error occurs
     */
    /*
     * Statement getMaxRows did not return value set by setMaxRows.
     */
    public int getMaxRows() throws SQLException {
        connection.log("Statement.getMaxRows");
        return maxRows;
    }

    /**
     * Sets the limit for the maximum number of rows that any
     * ResultSet can contain to the given number.
     * If the limit is exceeded, the excess
     * rows are silently dropped.
     *
     * @param max the new max rows limit; zero means unlimited 
     * @exception SQLException if a database access error occurs
     */
    /*
     * Statement setMaxRows did not have a check for invalid Max Row Size.
     */
    public void setMaxRows(int max) throws SQLException {
        if (max < 0)
            ScDBError.check_error(-62, "" + max);
        maxRows = max;
    }

    /**
     * Sets escape processing on or off.
     * If escape scanning is on (the default), the driver will do
     * escape substitution before sending the SQL to the database.
     *
     * Note: Since prepared statements have usually been parsed prior
     * to making this call, disabling escape processing for prepared
     * statements will have no effect.
     *
     * @param enable true to enable; false to disable
     * @exception SQLException if a database access error occurs
     */
    public void setEscapeProcessing(boolean enable) throws SQLException {
        connection.log("Statement.setEscapeProcessing");
    }

    /**
     * Retrieves the number of seconds the driver will
     * wait for a Statement to execute. If the limit is exceeded, a
     * SQLException is thrown.
     *
     * @return the current query timeout limit in seconds; zero means unlimited 
     * @exception SQLException if a database access error occurs
     */
    public int getQueryTimeout() throws SQLException {
        //milliseconds
        return 30000;
    }

    /**
     * Sets the number of seconds the driver will
     * wait for a Statement to execute to the given number of seconds.
     * If the limit is exceeded, a SQLException is thrown.
     *
     * @param seconds the new query timeout limit in seconds; zero means 
     * unlimited 
     * @exception SQLException if a database access error occurs
     */
    /*
     * Sets the socket read timeout period. Used for Query Timeout.
     */
    public void setQueryTimeout(int seconds) throws SQLException {
        if (seconds < 0)
            ScDBError.check_error(-59, "Query Timeout Cannot be negative");
        iQueryTimeout = seconds;
    }

    /**
     * Cancels this <code>Statement</code> object if both the DBMS and
     * driver support aborting an SQL statement.
     * This method can be used by one thread to cancel a statement that
     * is being executed by another thread.
     *
     * @exception SQLException if a database access error occurs
     */
    public void cancel() throws SQLException {
    }

    /**
     * Retrieves the first warning reported by calls on this Statement.
     * Subsequent Statement warnings will be chained to this
     * SQLWarning.
     *
     * <p>The warning chain is automatically cleared each time
     * a statement is (re)executed.
     *
     * <P><B>Note:</B> If you are processing a ResultSet, any
     * warnings associated with ResultSet reads will be chained on the
     * ResultSet object.
     *
     * @return the first SQLWarning or null 
     * @exception SQLException if a database access error occurs
     */
    public SQLWarning getWarnings() throws SQLException {
        connection.log("Statement.getWarnings");
        return null;
    }

    /**
     * Clears all the warnings reported on this <code>Statement</code>
     * object. After a call to this method,
     * the method <code>getWarnings</code> will return
     * null until a new warning is reported for this Statement.
     *
     * @exception SQLException if a database access error occurs
     */
    public void clearWarnings() throws SQLException {
    }

    /**
     * Defines the SQL cursor name that will be used by
     * subsequent Statement <code>execute</code> methods. This name can then be
     * used in SQL positioned update/delete statements to identify the
     * current row in the ResultSet generated by this statement.  If
     * the database doesn't support positioned update/delete, this
     * method is a noop.  To insure that a cursor has the proper isolation
     * level to support updates, the cursor's SELECT statement should be
     * of the form 'select for update ...'. If the 'for update' phrase is 
     * omitted, positioned updates may fail.
     *
     * <P><B>Note:</B> By definition, positioned update/delete
     * execution must be done by a different Statement than the one
     * which generated the ResultSet being used for positioning. Also,
     * cursor names must be unique within a connection.
     *
     * Manoj Thoniyil - 05/22/2007
     * As this is a no-op for Profile there's no need to do any thing.
     *
     * @param name the new cursor name, which must be unique within
     *             a connection
     * @exception SQLException if a database access error occurs
     */
    public void setCursorName(String name) throws SQLException {
    }

    //----------------------- Multiple Results --------------------------

    /**
     * Executes a SQL statement that may return multiple results.
     * Under some (uncommon) situations a single SQL statement may return
     * multiple result sets and/or update counts.  Normally you can ignore
     * this unless you are (1) executing a stored procedure that you know may
     * return multiple results or (2) you are dynamically executing an
     * unknown SQL string.  The  methods <code>execute</code>,
     * <code>getMoreResults</code>, <code>getResultSet</code>,
     * and <code>getUpdateCount</code> let you navigate through multiple results.
     *
     * The <code>execute</code> method executes a SQL statement and indicates the
     * form of the first result.  You can then use getResultSet or
     * getUpdateCount to retrieve the result, and getMoreResults to
     * move to any subsequent result(s).
     *
     * @param sql any SQL statement
     * @return true if the next result is a ResultSet; false if it is
     * an update count or there are no more results
     * @exception SQLException if a database access error occurs
     * @see #getResultSet
     * @see #getUpdateCount
     * @see #getMoreResults
     */
    /*
     * Closed Statement were allowing operation. Additional
     * check incorporated to check for already closed Statement
     *
     */
    public boolean execute(String sql) throws SQLException {
        connection.log("Statement.execute(" + sql + ")");
        if (closed) {
            ScDBError.check_error(-9, "");
        }
        ini();
        if (getSqlKind(sql) == 0) {
            lastRs = (ScJdbcResultSet) executeQuery(sql);
            if (lastRs == null) return false;
            return true;
        } else {
            rowCount = executeUpdate(sql);
            return false;
        }
    }

    /**
     * Returns the type of SQL like 0 for select or open. 1 for execute. 
     * @param sql The SQl to be checked
     * @return the Type of SQL
     */
    byte getSqlKind(String sql) {
        String sqlKind = sql.trim();

        if (sqlKind.regionMatches(true, 0, "select", 0, 6))
            return 0;
        else if (sqlKind.regionMatches(true, 0, "execute", 0, 7)) {
            if (connection.i_bAutoCommit) return 0;
            else return 1;
        } else if (sqlKind.regionMatches(true, 0, "open", 0, 4))
            return 0;
        else return 1;
    }

    /**
     *  Returns the current result as a <code>ResultSet</code> object. 
     *  This method should be called only once per result.
     *
     * @return the current result as a ResultSet; null if the result
     * is an update count or there are no more results
     * @exception SQLException if a database access error occurs
     * @see #execute
     */
    public ResultSet getResultSet() throws SQLException {
        connection.log("Statement.getResultSet");
        return lastRs;
    }

    /**
     *  Returns the current result as an update count;
     *  if the result is a ResultSet or there are no more results, -1
     *  is returned. 
     *  This method should be called only once per result.
     *
     * @return the current result as an update count; -1 if it is a
     * ResultSet or there are no more results
     * @exception SQLException if a database access error occurs
     * @see #execute
     */
    public int getUpdateCount() throws SQLException {
        connection.log("Statement.getUpdateCount");
        return rowCount;
    }

    /**
     * Moves to a Statement's next result.  It returns true if 
     * this result is a ResultSet.  This method also implicitly
     * closes any current ResultSet obtained with getResultSet.
     *
     * There are no more results when (!getMoreResults() &&
     * (getUpdateCount() == -1)
     *
     * @return true if the next result is a ResultSet; false if it is
     * an update count or there are no more results
     * @exception SQLException if a database access error occurs
     * @see #execute
     */
    public boolean getMoreResults() throws SQLException {
        connection.log("Statement.getMoreResults");
        return false;
    }

    //--------------------------JDBC 2.0-----------------------------

    /**
     * JDBC 2.0
     *
     * Gives the driver a hint as to the direction in which
     * the rows in a result set
     * will be processed. The hint applies only to result sets created 
     * using this Statement object.  The default value is 
     * ResultSet.FETCH_FORWARD.
     * <p>Note that this method sets the default fetch direction for 
     * result sets generated by this <code>Statement</code> object.
     * Each result set has its own methods for getting and setting
     * its own fetch direction.
     * @param direction the initial direction for processing rows
     * @exception SQLException if a database access error occurs
     * or the given direction
     * is not one of ResultSet.FETCH_FORWARD, ResultSet.FETCH_REVERSE, or
     * ResultSet.FETCH_UNKNOWN
     */
    /*
     * If lastRs is not yet initialized then setFetchDirection
     * validation incorporated. ID : STMT0003 : Chirodip Pal 31/05/2006
     */
    public void setFetchDirection(int direction) throws SQLException {
        connection.log("Statement.setFetchDirection");
        if (direction == ResultSet.FETCH_REVERSE) {
            ScDBError.check_error(-53, Integer.toString(direction));
        }
        if (lastRs == null)                                 // If lastRs is not null, then use ScJDBCResultSet setFetchDirection validation
        {
            if (direction != ResultSet.FETCH_FORWARD) {
                ScDBError.check_error(-60, Integer.toString(direction));
            }
        } else
            lastRs.setFetchDirection(direction);
    }

    /**
     * JDBC 2.0
     *
     * Retrieves the direction for fetching rows from
     * database tables that is the default for result sets
     * generated from this <code>Statement</code> object.
     * If this <code>Statement</code> object has not set
     * a fetch direction by calling the method <code>setFetchDirection</code>,
     * the return value is implementation-specific.
     *
     * @return the default fetch direction for result sets generated
     *          from this <code>Statement</code> object
     * @exception SQLException if a database access error occurs
     */
    /*
     * Statement getFetchDirection returning ResultSet getFetchDirection()
     * which is initialized in the execute methods. The call on the method
     * if done before any execute method call throws exception
     */
    public int getFetchDirection() throws SQLException {
        connection.log("Statement.getFetchDirection");
        if (lastRs != null && lastRs.getFetchDirection() > 0)
            return lastRs.getFetchDirection();
        return default_fetch_direction;
    }

    /**
     * JDBC 2.0
     *
     * Gives the JDBC driver a hint as to the number of rows that should 
     * be fetched from the database when more rows are needed.  The number 
     * of rows specified affects only result sets created using this 
     * statement. If the value specified is zero, then the hint is ignored.
     * The default value is zero.
     *
     * @param rows the number of rows to fetch
     * @exception SQLException if a database access error occurs, or the
     * condition 0 <= rows <= this.getMaxRows() is not satisfied.
     */
    public void setFetchSize(int rows) throws SQLException {
        connection.log("Statement.setFetchSize");

        if (rows <= 0) ScDBError.check_error(-32, "ScStatement");
        if (dBStatement != null)
            ((ScMsqlQueryStatement) dBStatement).sqlQuailfier = ((ScMsqlQueryStatement) dBStatement).sqlQuailfier + "/PREPARE=1/ROWS = " + rows;
        fetchRow = rows;
    }

    /** Allow the use of an effective date to support standard PROFILE/IBS effective dated
     * maintenace processing. The date specified must be greater than the current system
     * date. This qualifier is valid on the BUFFER NEW command for buffered operations, or
     * on individual INSERT, UPDATE, or DELETE commands when not using buffered operations.
     * example: EFD=a julian date/USING=(C1=1)
     *
     * @param julinDate the date to be set
     * @exception SQLException if the input date is invalid
     */
    public void setEFD(int julinDate) throws SQLException {
        connection.log("Statement.setEFD");

        if (julinDate <= 0) ScDBError.check_error(-32, "ScStatement");
        if (dBStatement != null)
            ((ScMsqlDDLStatement) dBStatement).sqlQuailfier = ((ScMsqlQueryStatement) dBStatement).sqlQuailfier + "/EFD= " + julinDate;
        efdJulianDate = julinDate;
    }

    /**
     * JDBC 2.0
     *
     * Retrieves the number of result set rows that is the default 
     * fetch size for result sets
     * generated from this <code>Statement</code> object.
     * If this <code>Statement</code> object has not set
     * a fetch size by calling the method <code>setFetchSize</code>,
     * the return value is implementation-specific.
     * @return the default fetch size for result sets generated
     *          from this <code>Statement</code> object
     * @exception SQLException if a database access error occurs
     */
    public int getFetchSize() throws SQLException {
        connection.log("Statement.getFetchSize");
        if (fetchRow > 0) return fetchRow;
        else return i_dDbAccess.getDefaultPrefetch();
    }

    /**
     * JDBC 2.0
     *
     * Retrieves the result set concurrency (readonly,0 or updatable, 1).
     * @return int
     */
    public int getResultSetConcurrency() throws SQLException {
        connection.log("Statement.getResultSetConcurrency");
        return resultSetConcurrency;
    }

    /**
     * JDBC 2.0
     *
     * Determine the result set type. TYPE_FORWARD_ONLY, TYPE_SCROLL_INSENSITIVE,
     * TYPE_SCROLL_SENSITIVE
     */
    public int getResultSetType() throws SQLException {
        connection.log("Statement.getResultSetType");
        return resultSetType;
    }

    /**
     * JDBC 2.0
     *
     * Adds a SQL command to the current batch of commmands for the statement.
     * This method is optional.
     *
     * @param sql typically this is a static SQL INSERT or UPDATE statement
     * @exception SQLException if a database access error occurs, or the
     * driver does not support batch statements
     */
    public void addBatch(String sql) throws SQLException {

        dBStatement = new ScMsqlDDLStatement(sql);
        if (this.efdJulianDate > 0) ((ScMsqlDDLStatement) dBStatement).setEFD(efdJulianDate);

        if (connection.i_bAutoCommit) {
            ScDBError.check_error(-50, "ScStatement");
            return;
        }

        i_batchSql.addElement(dBStatement);
    }

    /**
     * JDBC 2.0
     *
     * Makes the set of commands in the current batch empty.
     * This method is optional.
     *
     * @exception SQLException if a database access error occurs or the
     * driver does not support batch statements
     */
    public void clearBatch() throws SQLException {
        if (i_batchSql.size() > 0) i_batchSql.clear();
    }

    /**
     * JDBC 2.0
     *
     * Submits a batch of commands to the database for execution.
     * This method is optional.
     *
     * @return an array of update counts containing one element for each
     * command in the batch.  The array is ordered according 
     * to the order in which commands were inserted into the batch.
     * @exception SQLException if a database access error occurs or the
     * driver does not support batch statements
     * executeBatch was allowing operations returning resultset.
     * Incorporated check to block such operations.
     */
    public int[] executeBatch() throws SQLException {
        int i_countBatch = 0;
        int i_countBatched = i_batchSql.size();
        int i_updateCount[] = new int[i_countBatched];
        String[] batchResult = null;
        if (i_countBatched <= 0) {
            int i_tempUpdateCount[] = new int[0];
            return i_tempUpdateCount;
        }
        try {
            for (; i_countBatch < i_countBatched; i_countBatch++) {
                String sqlQuery = ((ScMsqlDDLStatement) i_batchSql.elementAt(i_countBatch)).getSqlStatment();
                if (getSqlKind(sqlQuery) == 0) {
                    i_updateCount[i_countBatch] = EXECUTE_FAILED;
                    ScDBError.throwBatchUpdateException(-1, "Invalid SQL command " +
                            i_countBatch, i_countBatch, i_updateCount);
                }
            }
            batchResult = connection.batchCommit();
        } catch (SQLException sqlException) {
            if (sqlException instanceof BatchUpdateException)
                throw sqlException;
            ScDBError.throwBatchUpdateException(-1, sqlException.getMessage(), i_countBatch, i_updateCount);
        } catch (Exception exception) {
            exception.printStackTrace();
            ScDBError.throwBatchUpdateException(-2, exception.getMessage(), i_countBatch, i_updateCount);
        } finally {
            i_batchSql.removeAllElements();
            connection.i_bAutoCommit = true;
        }

        ScStringTokenizer sToken = new ScStringTokenizer(batchResult[1], "|", false);
        i_countBatch = 0;
        while (sToken.hasMoreTokens()) {
            i_updateCount[i_countBatch] = Integer.valueOf(sToken.nextToken()).intValue();
            i_countBatch++;
            if (i_countBatch == i_countBatched) break;
        }

        return i_updateCount;
    }

    /**
     * JDBC 2.0
     *
     * Returns the <code>Connection</code> object
     * that produced this <code>Statement</code> object.
     * @return the connection that produced this statement
     * @exception SQLException if a database access error occurs
     */
    public Connection getConnection() throws SQLException {
        connection.log("Statement.getConnection");
        return connection;
    }

    /**
     * If connection autocommit is set to false, this method gets all the
     * statements in current batch and adds to the Buffer. The Buffer so formed 
     * in Profile side, will be committed ( executed in DB) by commit call.
     * @throws SQLException If databse exception occurs
     * @throws Exception If any other exception occurs.
     */
    public void sendBatch()
            throws SQLException, Exception {
        if ((i_batchSql.size() == 0) || (connection.i_bAutoCommit)) return;
        Enumeration e = i_batchSql.elements();
        String sql = new String();
        int i = 0;

        try {
            String BufferName = i_dDbAccess.getBufferName();
            while (e.hasMoreElements()) {
                dBStatement = (ScMsqlDDLStatement) e.nextElement();
                if (dBStatement instanceof ScMsqlDDLStatement) {
                    sql = ((ScMsqlDDLStatement) dBStatement).i_sSqlstmt;
                    if (connection.i_iDefaultBatch == 0) sql = "BUFFER NEW " + BufferName + " " + sql;
                    else sql = "BUFFER ADD " + BufferName + " " + sql;
                    ((ScMsqlDDLStatement) dBStatement).i_sSqlstmt = sql;
                }

                i_dDbAccess.executeProcedure(dBStatement);
                connection.i_iDefaultBatch++;
                i++;
            }
        } finally {
            i_batchSql.removeAllElements();
        }
    }

    /**
     * This method adds the input statement and adds to the Buffer. The Buffer 
     * so formed in Profile side, will be committed ( executed in DB) by commit call.
     * @param dBStatement the ScMsqlDDLStatement statement to be batched     
     * @throws SQLException If databse exception occurs
     * @throws Exception If any other exception occurs.
     */
    //add for TP, Jan 30, 2002
    protected void sendFence(ScMsqlDDLStatement dBStatement)
            throws SQLException, Exception {
        String BufferName = i_dDbAccess.getBufferName();
        if (dBStatement instanceof ScMsqlDDLStatement) {
            String sql = ((ScMsqlDDLStatement) dBStatement).i_sSqlstmt;
            if (connection.i_iDefaultBatch == 0) sql = "BUFFER NEW " + BufferName + " " + sql;
            else sql = "BUFFER ADD " + BufferName + " " + sql;
            ((ScMsqlDDLStatement) dBStatement).i_sSqlstmt = sql;
        }

        i_dDbAccess.executeProcedure(dBStatement);
        connection.i_iDefaultBatch++;

    }

    /**
     * Returns the ScDBStatement like ScMsqlDDLStatement etc.
     * instance. 
     * @return The ScDBStatement like ScMsqlDDLStatement etc
     */
    public ScDBStatement getDbStatement() {
        return dBStatement;
    }

    /**
     * Forms the cells ( Rows and Columns) using ScMSQLFormat
     * @param dBStatement Instance of ScMsqlQueryStatement
     * @throws SQLException If any database access error occurs
     */
    /*
     * When the sTempResult[2] consists "" and sTempResult[1] is 1, it
     * means the result is null. When the count is more than 0, but the
     * trim.length() is 0 it is in the form \r\n\r\n i.e. multiple rows
     * with single column. Whenever multi columns are selected
     * the \t which comes in between of \r\n makes the cells formation ok
     * later on. Only the mutli row single column selection and
     * single row single column selection with no data ( null) requires
     * special treatment. The row count is required for the later part of
     * the implementation.
     */
    protected void firstFetch(ScDBStatement dBStatement)
            throws SQLException {
        if (dBStatement instanceof ScMsqlQueryStatement) {
            ScMsqlQueryStatement stmt = (ScMsqlQueryStatement) dBStatement;
            i_ahHash = stmt.getColIndexColNameMap();
            description = ScMSQLFormat.parseRawResult(stmt.getDBA(), i_ahHash);
            //fix for memo or blob
            ScMSQLFormat.updateRowCount(stmt.getRowCount());
            ScMSQLFormat.parseRawResult(cells, stmt.getReply(), 0, description);
            i_iTotalRows = cells.rows();
            stmt.setDBA(null);
            stmt.setReply(null);    //release memory RMX

            if (!i_ahHash.isEmpty() && (resultSetConcurrency == ResultSet.CONCUR_UPDATABLE)) {
                copyDesc = new Object[cells.rows()][i_ahHash.size()];
                for (int i = 0; i < cells.rows(); i++) {
                    for (int j = 0; j < i_ahHash.size(); j++) {
                        copyDesc[i][j] = cells.elementAt(i, j);
                    }
                }
            }
            if (i_ahHash.isEmpty()) {
                i_ahHash.put(new Integer("1"), "COL1");
                //FID,DI,LEN,DFT,TYP,DES,SIZ,REQ,DEC,NOD 
                String[] s = {stmt.getSqlStatment(), "COL", String.valueOf(stmt.getSqlStatment().length()),
                        "", "T", "", "", "", "", ""};
                description = new String[1][1];
                description[0] = s;
            }
        }
    }

    /**
     * Forms the cells ( rows and columns) using ScMSQLFormat 
     * @param dBStatement Instance of ScMsqlQueryStatement
     * @throws SQLException If any database error occurs.
     * @see ScMSQLFormat#parseRawResult
     */
    public void add(ScDBStatement dBStatement)
            throws SQLException {
        if (dBStatement instanceof ScMsqlQueryStatement) {
            ScMsqlQueryStatement stmt = (ScMsqlQueryStatement) dBStatement;

            if (resultSetType == ResultSet.TYPE_SCROLL_INSENSITIVE) {
                ScMSQLFormat.parseRawResult(cells, stmt.getReply(), i_iTotalRows);
            } else {
                cells.removeAllElements();
                this.i_iCurrentRow = 1;
                ScMSQLFormat.parseRawResult(cells, stmt.getReply(), 0);
            }

            stmt.setReply(null);    //release memory RMX
            i_iTotalRows = cells.rows(); //jiaq, performance
            int iColCount = i_ahHash.size();

            if (resultSetConcurrency == ResultSet.CONCUR_UPDATABLE) {
                copyDesc = null;
                copyDesc = new Object[i_iTotalRows][iColCount];
                for (int i = 0; i < i_iTotalRows; i++) {
                    for (int j = 0; j < iColCount; j++) {
                        copyDesc[i][j] = cells.elementAt(i, j);
                    }
                }
            }
        }
    }

    /**
     * Initializating cell matrix of resultset
     *
     */

    protected void ini() {
        try {
            i_iCurrentRow = 0;
            cells = null;
            cells = new ScMatrix();
            //if (cells.rows()>0) cells.removeAllElements();
            i_ahHash.clear();
            i_iTotalRows = 0;
            gotLastBatch = false;
            description = null;
            lastRs = null;
        } catch (Exception e) {
        }


    }

    /**
     * Gets the Column Alias names in a sql query
     * @param sql The SQL Query
     * @return Hashtable a collection of Column Alias names
     */
    protected Hashtable asClearUp(String sql) {
        Hashtable map = new Hashtable();
        String X = sql.toUpperCase().trim();
        int iSelect = X.indexOf("SELECT ");
        if (iSelect != 0) return map;

        int iFrom = X.indexOf("FROM ");
        String pieceColumns = X.substring(iSelect + 6, iFrom).trim(); //columns

        //StringBuffer ss = new StringBuffer();
        String wrdx;
        int i;

        StringTokenizer parser;
        int iColIndex = 1;
        if (pieceColumns.indexOf(" AS ") > 0) {
            parser = new StringTokenizer(pieceColumns, ",", false);
            while (parser.hasMoreElements()) {
                wrdx = (String) parser.nextElement();
                i = wrdx.lastIndexOf(" AS ");
                if (i > 0) {
                    wrdx = wrdx.substring(i + 4, wrdx.length());
                }//if
                map.put(new Integer(iColIndex++), wrdx.trim());
            }//while
        }//if

        return map;

    }

    //--------------------------JDBC 3.0-----------------------------
    /* (non-Javadoc)
     * @see java.sql.Statement#getMoreResults(int)
     */
    public boolean getMoreResults(int current) throws SQLException {
        ScDBError.check_error(-84, "getMoreResults(int current)");
        return false;
    }

    /*
     * @author patilb
     * @since  3.0
     * @see java.sql.Statement#getGeneratedKeys()
     */
    public ResultSet getGeneratedKeys() throws SQLException {
        connection.log("Statement.getGeneratedKeys");
        ScMsqlDDLStatement statement = (ScMsqlDDLStatement) dBStatement;

        if (getAutoGeneratedKeys() == Statement.RETURN_GENERATED_KEYS) {
            //getGeneratedKeys() is supported for INSERT sql statements only.
            if (statement.getSqlStatment().compareToIgnoreCase("INSERT") < 0)
                ScDBError.check_error(-86, null);
        }

        //thrid token is always a table name
        String tableName = statement.getSqlStatment().split("[' ','(',')' ]")[2];
        ScMsqlQueryStatement sqlStatement = new ScMsqlQueryStatement(tableName);
        sqlStatement.setReply(statement.getGeneratedKeys());
        sqlStatement.setServerClass(statement.getServerClass());
        firstFetch(sqlStatement);
        //Column size is hardcode to 12 as in profile only numeric columns can generate incremental value.
        //Max size of numeric type column is 12
        description[0][2] = "12";
        this.resultSetType = ResultSet.TYPE_SCROLL_INSENSITIVE;
        this.resultSetConcurrency = ResultSet.TYPE_SCROLL_INSENSITIVE;
        return new ScJdbcResultSet(connection, this);
    }

    /* (non-Javadoc)
     * @see java.sql.Statement#executeUpdate(java.lang.String, int)
     */
    public int executeUpdate(String sql, int autoGeneratedKeys) throws SQLException {
        if (autoGeneratedKeys == Statement.RETURN_GENERATED_KEYS) {
            //set  autoGeneratedKeys only for "INSERT" statement.
            String sqlOperation = sql.split("[' ','(',')' ]")[0];
            if (sqlOperation.equalsIgnoreCase("INSERT"))
                setAutoGeneratedKeys(autoGeneratedKeys);
        }
        return executeUpdate(sql);
    }

    /* (non-Javadoc)
     * @see java.sql.Statement#executeUpdate(java.lang.String, int[])
     */
    public int executeUpdate(String sql, int[] columnIndexes) throws SQLException {
        ScDBError.check_error(-84, "executeUpdate(String sql, int[] columnIndexes)");
        return -1;
    }

    /* (non-Javadoc)
     * @see java.sql.Statement#executeUpdate(java.lang.String, java.lang.String[])
     */
    public int executeUpdate(String sql, String[] columnNames) throws SQLException {
        ScDBError.check_error(-84, "executeUpdate(String sql, String[] columnNames)");
        return -1;
    }

    /*
     * @author patilb
     * @since  3.0
     * @see java.sql.Statement#execute(java.lang.String, int)
     */
    public boolean execute(String sql, int autoGeneratedKeys) throws SQLException {
        if (autoGeneratedKeys == Statement.RETURN_GENERATED_KEYS) {
            //set  autoGeneratedKeys only for "INSERT" statement.
            String sqlOperation = sql.split("[' ','(',')' ]")[0];
            if (sqlOperation.equalsIgnoreCase("INSERT"))
                setAutoGeneratedKeys(autoGeneratedKeys);
        }
        return this.execute(sql);
    }

    /*
     * @author patilb
     * @since  3.0
     * @see java.sql.Statement#execute(java.lang.String, int[])
     */
    public boolean execute(String sql, int[] columnIndexes) throws SQLException {
        ScDBError.check_error(-84, "execute(String sql, int[] columnIndexes)");
        return false;
    }

    /*
     * @author patilb
     * @since  3.0
     * @see java.sql.Statement#execute(java.lang.String, java.lang.String[])
     */
    public boolean execute(String sql, String[] columnNames) throws SQLException {
        ScDBError.check_error(-84, "execute(String sql, String[] columnNames)");
        return false;
    }

    /* (non-Javadoc)
     * @see java.sql.Statement#getResultSetHoldability()
     */
    public int getResultSetHoldability() throws SQLException {
        ScDBError.check_error(-52, "java.sql.Statement#getResultSetHoldability()");
        return 0;
    }

    public ScConnection getScConnection() {
        return connection;
    }

    @Override
    public boolean isCloseOnCompletion() {
        return false;
    }

    @Override
    public void closeOnCompletion() {

    }

    @Override
    public boolean isPoolable() {
        return false;
    }

    @Override
    public void setPoolable(boolean poolable) {

    }

    @Override
    public boolean isClosed() {
        return closed;
    }

    @Override
    public boolean isWrapperFor(Class<?> iface) {
        return false;
    }

    @Override
    public <T> T unwrap(Class<T> iface) {
        return null;
    }

    protected Object clone()
            throws CloneNotSupportedException {
        return super.clone();
    }

    protected int getAutoGeneratedKeys() {
        return autoGeneratedKeysOption;
    }

    protected void setAutoGeneratedKeys(int autoGeneratedKeys) {
        this.autoGeneratedKeysOption = autoGeneratedKeys;
    }
}	

