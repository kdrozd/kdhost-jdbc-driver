/**
 * A ResultSet object is a table that contains the results of
 * executing an SQL query.
 *
 * @version 1.0  Spet. 28 1999
 * @author Quansheng Jia
 * @see
 */

package sanchez.jdbc.driver;

import java.io.InputStream;
import java.io.Reader;
import java.math.BigDecimal;

import sanchez.jdbc.dbaccess.*;
import sanchez.jdbc.utils.ScSQLInputImpl;
import sanchez.jdbc.utils.ScSerialBlob;
import sanchez.jdbc.utils.ScSerialClob;

import java.sql.*;
import java.util.Hashtable;
import java.util.Calendar;
import java.net.URL;
import java.text.DateFormat;

import sanchez.utils.ScSerialUtils;
import sanchez.utils.ScUtility;

import java.util.Enumeration;
import java.io.ByteArrayInputStream;
import java.io.UnsupportedEncodingException;

import sanchez.base.ScBundle;
import sanchez.base.ScResourceKeys;
import sanchez.him_pa.utils.ScUtils;

/**
 * <P>A ResultSet provides access to a table of data.  A ResultSet
 * object is usually generated by executing a Statement. 
 *
 * <P>A ResultSet maintains a cursor pointing to its current row of
 * data.  Initially the cursor is positioned before the first row.
 * The 'next' method moves the cursor to the next row.
 *
 * <P>The getXXX methods retrieve column values for the current
 * row.  You can retrieve values using either the index number of the
 * column or the name of the column.  In general, using the 
 * column index will be more efficient.  Columns are numbered from 1.
 *
 * <P>For maximum portability, ResultSet columns within each row should be
 * read in left-to-right order and each column should be read only once.
 *
 * <P>For the getXXX methods, the JDBC driver attempts to convert the
 * underlying data to the specified Java type and returns a suitable
 * Java value.  See the JDBC specification for allowable mappings
 * from SQL types to Java types with the ResultSet.getXXX methods.
 *
 * <P>Column names used as input to getXXX methods are case
 * insensitive.  When performing a getXXX using a column name, if
 * several columns have the same name, then the value of the first
 * matching column will be returned. The column name option is
 * designed to be used when column names are used in the SQL
 * query. For columns that are NOT explicitly named in the query, it
 * is best to use column numbers. If column names are used, there is
 * no way for the programmer to guarantee that they actually refer to
 * the intended columns.
 *
 * <P>A ResultSet is automatically closed by the Statement that
 * generated it when that Statement is closed, re-executed, or used
 * to retrieve the next result from a sequence of multiple results.
 *
 * <P>The number, types and properties of a ResultSet's columns are
 * provided by the ResulSetMetaData object returned by the getMetaData
 * method.
 *
 * @see Statement#executeQuery
 * @see Statement#getResultSet
 * @see ResultSetMetaData
 */
public class ScJdbcResultSet implements ResultSet {
    private ScConnection connection;
    private ScStatement statement;
    private boolean closed;
    private boolean explicitlyClosed;
    public boolean closeStatementOnClose;

    private ScDBStatement i_dBStatement;
    public int fetchDirection = ResultSet.FETCH_FORWARD;
    int oldCurrentRow;
    int currentColIndex = 0;

    /**
     * Constructs a ResultSet object using a connection and Statement
     * @param c ScConnection object
     * @param s ScStatement object
     * @exception SQLException when database error occurs
     */
    public ScJdbcResultSet(ScConnection c, ScStatement s)
            throws SQLException {
        if (c.resHoldability == ResultSet.HOLD_CURSORS_OVER_COMMIT || s.resHoldabilty == ResultSet.HOLD_CURSORS_OVER_COMMIT) {
            try {
                statement = (ScStatement) s.clone();
            } catch (CloneNotSupportedException e) {
                ScDBError.check_error(e);
            }
            statement.efdJulianDate = s.efdJulianDate;
            statement.fetchRow = s.fetchRow;
            statement.gotLastBatch = s.gotLastBatch;
            statement.i_iCurrentRow = s.i_iCurrentRow;
            statement.i_iTotalRows = s.i_iTotalRows;
            s.cells = null;
            s.copyDesc = null;
            s.dBStatement = null;
            s.description = null;
            s.i_ahHash = null;
            i_dBStatement = statement.getDbStatement();
            connection = c;
        } else {
            connection = c;
            statement = s;
            i_dBStatement = s.getDbStatement();
        }

        closeStatementOnClose = false;
        closed = false;
        explicitlyClosed = false;
    }

    /**
     * Moves the cursor down one row from its current position.
     * A ResultSet cursor is initially positioned before the first row; the
     * first call to next makes the first row the current row; the
     * second call makes the second row the current row, and so on. 
     *
     * <P>If an input stream is open for the current row, a call
     * to the method <code>next</code> will
     * implicitly close it. The ResultSet's warning chain is cleared
     * when a new row is read.
     *
     * @return true if the new current row is valid; false if there
     * are no more rows 
     * @exception SQLException if a database access error occurs
     */
    public boolean next() throws SQLException {

        connection.log("ResultSet.next");
        if (explicitlyClosed)
            ScDBError.check_error(-10, "next");

        if (closed)
            return false;

        if (statement.i_iTotalRows == 0) {
            internalClose();
            return false;
        }

        statement.i_iCurrentRow++;

        if (statement.maxRows != 0 && statement.i_iCurrentRow > statement.maxRows) {
            internalClose();
            return false;
        }

        if (statement.i_iCurrentRow > statement.i_iTotalRows) {
            try {
                if (statement.gotLastBatch) {
                    internalClose();
                    return false;
                }

                int queryRows = connection.i_dDbAccess.fetch(i_dBStatement);
                if (queryRows == 0) {
                    internalClose();
                    return false;
                }
                statement.add(i_dBStatement);
                if (((ScMsqlQueryStatement) i_dBStatement).getSqlStatus().equals("01500"))
                    statement.gotLastBatch = true;
                return true;
            } catch (Exception e) {
                ScDBError.check_error(e);
            }
        }
        return true;
    }

    /**
     * Releases this <code>ResultSet</code> object's database and
     * JDBC resources immediately instead of waiting for
     * this to happen when it is automatically closed.
     *
     * <P><B>Note:</B> A ResultSet is automatically closed by the
     * Statement that generated it when that Statement is closed,
     * re-executed, or is used to retrieve the next result from a
     * sequence of multiple results. A ResultSet is also automatically
     * closed when it is garbage collected.  
     *
     * @exception SQLException if a database access error occurs
     */
    public void close() throws SQLException {
        connection.log("ResultSet.close");
        internalClose();
        /* Manoj Thoniyil - 03/07/07
         * When the resultset is closed, the statement variables doesn't need to be initialized.
         * Freeing the variables cause the executeQuery() to fail after calling the clearParameters()
         * to reset the parameters.
         */
        /*
        statement.cells = null; 
        statement.copyDesc = null;
        statement.dBStatement = null;
        statement.description = null;
        statement.i_ahHash = null;
        */
        explicitlyClosed = true;
    }

    /**
     * Reports whether
     * the last column read had a value of SQL NULL.
     * Note that you must first call getXXX on a column to try to read
     * its value and then call wasNull() to see if the value read was
     * SQL NULL.
     *
     * @return true if last column read was SQL NULL and false otherwise
     * @exception SQLException if a database access error occurs
     */
    public boolean wasNull() throws SQLException {
        connection.log("ResultSet.wasNull");
        verify(currentColIndex);
        String o = (String) statement.cells.elementAt(statement.i_iCurrentRow - 1, currentColIndex - 1);
        if (o == null || o.equalsIgnoreCase("")) return true;
        else return false;
    }

    //======================================================================
    // Methods for accessing results by column index
    //======================================================================

    /**
     * Gets the value of a column in the current row as a Java String.
     *
     * @param columnIndex the first column is 1, the second is 2, ...
     * @return the column value; if the value is SQL NULL, the result is null
     * @exception SQLException if a database access error occurs
     *
     * @history - thoniyilmk - 01/27/2004 - CR 8054
     * 		This function was returning a 0 or 0.00 for a NULL returned for any
     * 		numeric columns. This function is suppose to return a NULL value, if 
     * 		a SQL NULL is received from the database. A check was made at the
     * 		beginning of the function to see if the value is NULL. If so, a NULL
     * 		is returned.
     */
    public String getString(int columnIndex) throws SQLException {
        connection.log("ResultSet.getString(" + columnIndex + ")");
        currentColIndex = columnIndex;
        if (this.wasNull()) return null;
        if (statement.i_iTotalRows == 0) return null;
        int type = getColumnType(columnIndex);
        if (type == Types.DATE) {
            java.sql.Date sDate = getDate(columnIndex);
            if (sDate == null) return "";
            return getFormatDate(sDate.toString());
        } else if (type == Types.TIME) {
            java.sql.Time sDate = getTime(columnIndex);
            if (sDate == null) return "";
            return getFormatTime(sDate.toString());
        } else if (type == -7) {
            boolean b = getBoolean(columnIndex);
            return String.valueOf(b);
        }

        String ss = (String) statement.cells.elementAt(statement.i_iCurrentRow - 1, columnIndex - 1);
        if ((type == 99) || (type == 7) || (type == 8) || (type == 2) || (type == 3) || (type == 6))
            return getFormatNumber(columnIndex, type, numberConvert(ss, columnIndex));

        try {
            //unicode supporting
            String fileEncoding = (String) connection.info.get("ENCODING");
            if (fileEncoding == null)
                ss = new String(ScUtils.stringToByte(ss), "8859_1");
            else if (fileEncoding.equalsIgnoreCase("UTF16") || fileEncoding.equalsIgnoreCase("UTF-16")) {
                ss = new String(ScUtils.stringToByte(ss), "UTF8");
                byte[] barray = ss.getBytes("UTF16");
                ss = new String(barray, "UTF16");
            } else ss = new String(ScUtils.stringToByte(ss), fileEncoding);
        } catch (Exception e) {
        }

        return ss;
    }

    /**
     * Gets the value of a column in the current row as a Java boolean.
     *
     * @param columnIndex the first column is 1, the second is 2, ...
     * @return the column value; if the value is SQL NULL, the result is false
     * @exception SQLException if a database access error occurs
     */
    public boolean getBoolean(int columnIndex) throws SQLException {
        connection.log("ResultSet.getBoolean");
        currentColIndex = columnIndex;
        if (statement.i_iTotalRows == 0) return false;
        String asTemp = (String) statement.cells.elementAt(statement.i_iCurrentRow - 1, columnIndex - 1);
        if ((asTemp.trim().compareTo("0") == 0) || (asTemp.trim().compareTo("") == 0) || (asTemp == null)) return false;
        else return true;
    }

    /**
     * Gets the value of a column in the current row as a Java byte.
     *
     * @param columnIndex the first column is 1, the second is 2, ...
     * @return the column value; if the value is SQL NULL, the result is 0
     * @exception SQLException if a database access error occurs
     * getByte returned incorrect value because it was returning the byte value of 
     * only the first character. Modified to return the whole byte.
     * As because getByte can be called on Double or an integer data type
     * interprated as NUMERIC(5,2) by profile, the intermediate Double value is used.
     */
    public byte getByte(int columnIndex) throws SQLException {
        connection.log("ResultSet.getByte");
        String str;
        currentColIndex = columnIndex;
        if ((str = getString(columnIndex)) == null || str.length() == 0) return (byte) 0;
        return (new Double(str)).byteValue();
    }

    /**
     * Gets the value of a column in the current row as a Java short.
     *
     * @param columnIndex the first column is 1, the second is 2, ...
     * @return the column value; if the value is SQL NULL, the result is 0
     * @exception SQLException if a database access error occurs
     */
    public short getShort(int columnIndex) throws SQLException {
        connection.log("ResultSet.getShort");
        currentColIndex = columnIndex;
        if (statement.i_iTotalRows == 0) return 0;
        String asTemp = (String) statement.cells.elementAt(statement.i_iCurrentRow - 1, columnIndex - 1);
        if (asTemp == null || asTemp.length() < 1) return 0;
        short i = 0;
        try {
            i = (short) Integer.parseInt(asTemp);
        } catch (Exception e) {
        }
        return i;
    }

    /**
     * Gets the value of a column in the current row as a Java int.
     *
     * @param columnIndex the first column is 1, the second is 2, ...
     * @return the column value; if the value is SQL NULL, the result is 0
     * @exception SQLException if a database access error occurs
     */
    public int getInt(int columnIndex) throws SQLException {
        connection.log("ResultSet.getInt");
        currentColIndex = columnIndex;
        if (statement.i_iTotalRows == 0) return 0;
        String asTemp = (String) statement.cells.elementAt(statement.i_iCurrentRow - 1, columnIndex - 1);
        if (asTemp == null || asTemp.length() < 1) return 0;
        int i = 0;
        try {
            i = Integer.parseInt(asTemp);
        } catch (Exception e) {
            i = 0;
        }
        return i;
    }

    /**
     * Gets the value of a column in the current row as a Java long.
     *
     * @param columnIndex the first column is 1, the second is 2, ...
     * @return the column value; if the value is SQL NULL, the result is 0
     * @exception SQLException if a database access error occurs
     *
     * @history - thoniyilmk - 06/03/2004 - CR 10424
     * 		Modified the function to check for nulls. A 0 (zero) 
     * 		is returned when a null is encountered. The function also 
     * 		throws a SQLException when an error occurs.
     */
    public long getLong(int columnIndex) throws SQLException {
        connection.log("ResultSet.getLong");
        currentColIndex = columnIndex;
        if (this.wasNull()) return 0;
        if (statement.i_iTotalRows == 0) return 0;
        String asTemp = (String) statement.cells.elementAt(statement.i_iCurrentRow - 1, columnIndex - 1);
        if (asTemp == null) return 0;
        long i = 0;
        try {
            i = (new Long(asTemp)).longValue();
        } catch (Exception e) {
            Object[] objs = {e.toString()};
            throw new SQLException(ScBundle.getMessage(ScResourceKeys.Error_in_getLong, objs));
        }
        return i;
    }

    /**
     * Gets the value of a column in the current row as a Java float.
     *
     * @param columnIndex the first column is 1, the second is 2, ...
     * @return the column value; if the value is SQL NULL, the result is 0
     * @exception SQLException if a database access error occurs
     */
    public float getFloat(int columnIndex) throws SQLException {
        connection.log("ResultSet.getFloat");
        currentColIndex = columnIndex;
        if (statement.i_iTotalRows == 0) return 0;
        String asTemp = (String) statement.cells.elementAt(statement.i_iCurrentRow - 1, columnIndex - 1);
        if (asTemp == null || asTemp.length() < 1) return 0;
        Float ret = new Float(asTemp);
        return ret.floatValue();
    }

    /**
     * Gets the value of a column in the current row as a Java double.
     *
     * @param columnIndex the first column is 1, the second is 2, ...
     * @return the column value; if the value is SQL NULL, the result is 0
     * @exception SQLException if a database access error occurs
     */
    public double getDouble(int columnIndex) throws SQLException {
        connection.log("ResultSet.getDouble");
        currentColIndex = columnIndex;
        if (statement.i_iTotalRows == 0) return 0;
        String asTemp = (String) statement.cells.elementAt(statement.i_iCurrentRow - 1, columnIndex - 1);
        if (asTemp == null || asTemp.length() < 1) return 0;
        Double adTemp = Double.valueOf(asTemp);

        return adTemp.doubleValue();
    }

    /**
     * Gets the value of a column in the current row as a java.math.BigDecimal object.
     *
     * @param columnIndex the first column is 1, the second is 2, ...
     * @param scale the number of digits to the right of the decimal
     * @return the column value; if the value is SQL NULL, the result is null
     * @exception SQLException if a database access error occurs
     * @deprecated
     *
     * @history - thoniyilmk - 11/21/2003 - CR 7176
     * 		This function was returning a 0 (zero), everytime called.
     * 		Removing the getLong() function, as it doesn't accept a decimal value
     * 		and throws an exception.
     * @history - thoniyilmk - 12/15/2003 - CR 7176
     * 		Modified the function to return a formatted number. A value "500", was
     * 		returned as it is. Now, it formats to "500.00".
     * @history - thoniyilmk - 12/18/2003 - CR 7766
     * 		Modified the function to look for precision in the meta data and set the
     * 		decimal point, accordingly. So, for a column with no decimal points (numeric),
     *  	there won't be any default zeros added to it.
     * @history - thoniyilmk - 01/27/2004 - CR 8054
     * 		This function was returning a 0 or 0.00 for a SQL NULL from the database.
     *  	This function is suppose to return a NULL value, if a SQL NULL is received 
     * 		from the database. A check was made at the	beginning of the function to 
     * 		see if the value is NULL. If so, a NULL	is returned.
     */
    public BigDecimal getBigDecimal(int columnIndex, int scale) throws SQLException {
        connection.log("ResultSet.getBigDecimal");
        currentColIndex = columnIndex;
        if (this.wasNull()) return null;
        if (statement.i_iTotalRows == 0) return BigDecimal.valueOf(0);
        String asTemp = (String) statement.cells.elementAt(statement.i_iCurrentRow - 1, columnIndex - 1);
        if ((asTemp == null) || (asTemp.length() == 0))
            asTemp = "0";

        int lenStr2 = 0;
        int indx = asTemp.indexOf(".");
        if (indx >= 0) {
            String tempStr1 = asTemp.substring(0, indx);
            String tempStr2 = asTemp.substring(indx + 1, asTemp.length());
            asTemp = tempStr1 + tempStr2;
            lenStr2 = tempStr2.length();
            if (lenStr2 >= scale)
                scale = lenStr2;
            else {
                for (; lenStr2 < scale; lenStr2++)
                    asTemp = asTemp + "0";
            }
        } else if (scale > 0) {
            for (; lenStr2 < scale; lenStr2++)
                asTemp = asTemp + "0";
        }

        BigDecimal b = BigDecimal.valueOf((new Long(asTemp)).longValue(), scale);
        return b;
    }

    /**
     * Gets the value of a column in the current row as a Java byte array.
     * The bytes represent the raw values returned by the driver.
     *
     * @param columnIndex the first column is 1, the second is 2, ...
     * @return the column value; if the value is SQL NULL, the result is null
     * @exception SQLException if a database access error occurs
     */
    public byte[] getBytes(int columnIndex) throws SQLException {
        connection.log("ResultSet.getBytes");
        currentColIndex = columnIndex;
        if (statement.i_iTotalRows == 0) return null;
        String asTemp = (String) statement.cells.elementAt(statement.i_iCurrentRow - 1, columnIndex - 1);
        if (asTemp == null) return null;
        try {
            byte[] b = ScUtils.stringToByte(asTemp);
            return b;
        } catch (Exception e) {
            ScDBError.check_error(e);
            return null;
        }
    }

    /**
     * Gets the value of a column in the current row as a java.sql.Date object.
     *
     * @param columnIndex the first column is 1, the second is 2, ...
     * @return the column value; if the value is SQL NULL, the result is null
     * @exception SQLException if a database access error occurs
     */
    public java.sql.Date getDate(int columnIndex) throws SQLException {
        connection.log("ResultSet.getDate");
        currentColIndex = columnIndex;
        if (statement.i_iTotalRows == 0) return null;
        String asTemp = (String) statement.cells.elementAt(statement.i_iCurrentRow - 1, columnIndex - 1);
        if (asTemp == null || asTemp.trim().length() < 1) return null;

        int year = 0, mm = 0, dd = 0;
        String stringDate = ScUtility.JulianDate(asTemp);

        String tokens[] = ScUtility.tokenParser(stringDate, "/");

        if (tokens[0].length() == 4) {
            //if the first element is year (year/month/day)
            year = Integer.valueOf(tokens[0]).intValue();
            mm = Integer.valueOf(tokens[1]).intValue();
            dd = Integer.valueOf(tokens[2]).intValue();
        } else {
            //if the first element is month (month/day/year)
            mm = Integer.valueOf(tokens[0]).intValue();
            dd = Integer.valueOf(tokens[1]).intValue();
            year = Integer.valueOf(tokens[2]).intValue();
        }

        return new Date(year - 1900, mm - 1, dd);
    }

    /**
     * Gets the value of a column in the current row as a java.sql.Time object.
     *
     * @param columnIndex the first column is 1, the second is 2, ...
     * @return the column value; if the value is SQL NULL, the result is null
     * @exception SQLException if a database access error occurs
     */
    public java.sql.Time getTime(int columnIndex) throws SQLException {
        connection.log("ResultSet.getTime");
        currentColIndex = columnIndex;
        if (statement.i_iTotalRows == 0) return null;
        String asTemp = (String) statement.cells.elementAt(statement.i_iCurrentRow - 1, columnIndex - 1);
        if (asTemp == null || asTemp.length() < 1) return null;
        return ScUtility.julianTimeToJavaTime(asTemp);

    }

    /**
     * Gets the value of a column in the current row as a java.sql.Timestamp object.
     *
     * @param columnIndex the first column is 1, the second is 2, ...
     * @return the column value; if the value is SQL NULL, the result is null
     * @exception SQLException if a database access error occurs
     */
    public java.sql.Timestamp getTimestamp(int columnIndex) throws SQLException {
        int j = getColumnType(columnIndex);
        try {
            switch (j) {
                case 92: // '\\'
                    long l = getTime(columnIndex).getTime();
                    return new Timestamp(l);

                case 91: // '['
                    long l1 = getDate(columnIndex).getTime();
                    return new Timestamp(l1);
                case 93:
                    String tStamp = getString(columnIndex);
                    return Timestamp.valueOf(tStamp);
                case -1:
                case 1: // '\001'
                case 12: // '\f'
                    return getFormatTimeStamp(getString(columnIndex));
            }
        } catch (Exception e) {
            if (getString(columnIndex) == null || getString(columnIndex).length() < 1) return null;
            Object[] objs = {getString(columnIndex).trim(), Integer.valueOf(String.valueOf(columnIndex))};
            throw new SQLException(ScBundle.getMessage(ScResourceKeys.GetTime_Failed, objs));
        }
        Object[] objs = {getString(columnIndex).trim(), Integer.valueOf(String.valueOf(columnIndex))};
        throw new SQLException(ScBundle.getMessage(ScResourceKeys.GetTime_Failed, objs));
    }

    /**
     * Gets the value of a column in the current row as a stream of
     * ASCII characters. The value can then be read in chunks from the
     * stream. This method is particularly
     * suitable for retrieving large LONGVARCHAR values.  The JDBC driver will
     * do any necessary conversion from the database format into ASCII.
     *
     * <P><B>Note:</B> All the data in the returned stream must be
     * read prior to getting the value of any other column. The next
     * call to a get method implicitly closes the stream.  Also, a
     * stream may return 0 when the method <code>available</code>
     * is called whether there is data
     * available or not.
     *
     * @param columnIndex the first column is 1, the second is 2, ...
     * @return a Java input stream that delivers the database column value
     * as a stream of one byte ASCII characters.  If the value is SQL NULL
     * then the result is null.  
     * @exception SQLException if a database access error occurs
     */
    public java.io.InputStream getAsciiStream(int columnIndex) throws SQLException {
        connection.log("ResultSet.getAsciiStream");
        currentColIndex = columnIndex;
        InputStream asciiStream;

        String asTemp = (String) statement.cells.elementAt(statement.i_iCurrentRow - 1, columnIndex - 1);
        if (asTemp == null) return null;
        try {
            if (isString(getColumnType(columnIndex)))
                asciiStream = new ByteArrayInputStream(((String) getObject(columnIndex)).getBytes("ASCII"));
            else
                throw new SQLException(ScBundle.getMessage(ScResourceKeys.Data_type_mismatch));
        } catch (UnsupportedEncodingException unsupportedencodingexception) {
            throw new SQLException(unsupportedencodingexception.getMessage());
        }
        return asciiStream;
    }

    /**
     * Gets the value of a column in the current row as a stream of
     * Unicode characters. The value can then be read in chunks from the
     * stream. This method is particularly
     * suitable for retrieving large LONGVARCHAR values.  The JDBC driver will
     * do any necessary conversion from the database format into Unicode.
     * The byte format of the Unicode stream must Java UTF-8,
     * as specified in the Java Virtual Machine Specification.
     *
     * <P><B>Note:</B> All the data in the returned stream must be
     * read prior to getting the value of any other column. The next
     * call to a get method implicitly closes the stream. Also, a
     * stream may return 0 when the method <code>available</code>
     * is called whether there is data
     * available or not.
     *
     * @param columnIndex the first column is 1, the second is 2, ...
     * @return a Java input stream that delivers the database column value
     * as a stream of two-byte Unicode characters.  If the value is SQL NULL
     * then the result is null.  
     * @exception SQLException if a database access error occurs
     * @deprecated
     */
    public java.io.InputStream getUnicodeStream(int columnIndex) throws SQLException {
        connection.log("ResultSet.getUnicodeStream");
        currentColIndex = columnIndex;

        String asTemp = (String) statement.cells.elementAt(statement.i_iCurrentRow - 1, columnIndex - 1);
        if (asTemp == null) return null;

        if (!isBinary(getColumnType(columnIndex)) && !isString(getColumnType(columnIndex)))
            throw new SQLException(ScBundle.getMessage(ScResourceKeys.Data_type_mismatch));
        Object obj = getObject(columnIndex);
        java.io.InputStream unicodeStream = null;

        if (obj == null) {
            return null;
        } else {
            unicodeStream = new java.io.StringBufferInputStream(obj.toString());
            return unicodeStream;
        }
    }

    /**
     * Gets the value of a column in the current row as a stream of
     * uninterpreted bytes. The value can then be read in chunks from the
     * stream. This method is particularly
     * suitable for retrieving large LONGVARBINARY values.
     *
     * <P><B>Note:</B> All the data in the returned stream must be
     * read prior to getting the value of any other column. The next
     * call to a get method implicitly closes the stream. Also, a
     * stream may return 0 when the method <code>available</code>
     * is called whether there is data
     * available or not.
     *
     * @param columnIndex the first column is 1, the second is 2, ...
     * @return a Java input stream that delivers the database column value
     * as a stream of uninterpreted bytes.  If the value is SQL NULL
     * then the result is null.  
     * @exception SQLException if a database access error occurs
     */
    public java.io.InputStream getBinaryStream(int columnIndex)
            throws SQLException {
        connection.log("ResultSet.getBinaryStream");
        currentColIndex = columnIndex;

        String asTemp = (String) statement.cells.elementAt(statement.i_iCurrentRow - 1, columnIndex - 1);
        if (asTemp == null) return null;
        if (!isBinary(getColumnType(columnIndex)))
            throw new SQLException(ScBundle.getMessage(ScResourceKeys.Data_type_mismatch));

        Object obj = getObject(columnIndex);
        if (obj == null)
            return null;
        else {
            return new ByteArrayInputStream((byte[]) obj);

        }
    }


    //======================================================================
    // Methods for accessing results by column name
    //======================================================================

    /**
     * Gets the value of a column in the current row as a Java String.
     *
     * @param columnName the SQL name of the column
     * @return the column value; if the value is SQL NULL, the result is null
     * @exception SQLException if a database access error occurs
     */
    public String getString(String columnName) throws SQLException {
        return getString(findColumn(columnName));
    }

    /**
     * Gets the value of a column in the current row as a Java boolean.
     *
     * @param columnName the SQL name of the column
     * @return the column value; if the value is SQL NULL, the result is false
     * @exception SQLException if a database access error occurs
     */
    public boolean getBoolean(String columnName) throws SQLException {
        return getBoolean(findColumn(columnName));
    }

    /**
     * Gets the value of a column in the current row as a Java byte.
     *
     * @param columnName the SQL name of the column
     * @return the column value; if the value is SQL NULL, the result is 0
     * @exception SQLException if a database access error occurs
     */
    public byte getByte(String columnName) throws SQLException {
        return getByte(findColumn(columnName));
    }

    /**
     * Gets the value of a column in the current row as a Java short.
     *
     * @param columnName the SQL name of the column
     * @return the column value; if the value is SQL NULL, the result is 0
     * @exception SQLException if a database access error occurs
     */
    public short getShort(String columnName) throws SQLException {
        return getShort(findColumn(columnName));
    }

    /**
     * Gets the value of a column in the current row as a Java int.
     *
     * @param columnName the SQL name of the column
     * @return the column value; if the value is SQL NULL, the result is 0
     * @exception SQLException if a database access error occurs
     */
    public int getInt(String columnName) throws SQLException {
        return getInt(findColumn(columnName));
    }

    /**
     * Gets the value of a column in the current row as a Java long.
     *
     * @param columnName the SQL name of the column
     * @return the column value; if the value is SQL NULL, the result is 0
     * @exception SQLException if a database access error occurs
     */
    public long getLong(String columnName) throws SQLException {
        return getLong(findColumn(columnName));
    }

    /**
     * Gets the value of a column in the current row as a Java float.
     *
     * @param columnName the SQL name of the column
     * @return the column value; if the value is SQL NULL, the result is 0
     * @exception SQLException if a database access error occurs
     */
    public float getFloat(String columnName) throws SQLException {
        return getFloat(findColumn(columnName));
    }

    /**
     * Gets the value of a column in the current row as a Java double.
     *
     * @param columnName the SQL name of the column
     * @return the column value; if the value is SQL NULL, the result is 0
     * @exception SQLException if a database access error occurs
     */
    public double getDouble(String columnName) throws SQLException {
        return getDouble(findColumn(columnName));
    }

    /**
     * Gets the value of a column in the current row as a java.math.BigDecimal 
     * object.
     *
     * @param columnName the SQL name of the column
     * @param scale the number of digits to the right of the decimal
     * @return the column value; if the value is SQL NULL, the result is null
     * @exception SQLException if a database access error occurs
     * @deprecated
     */
    public BigDecimal getBigDecimal(String columnName, int scale) throws SQLException {

        return getBigDecimal(findColumn(columnName), scale);
    }

    /**
     * Gets the value of a column in the current row as a Java byte array.
     * The bytes represent the raw values returned by the driver.
     *
     * @param columnName the SQL name of the column
     * @return the column value; if the value is SQL NULL, the result is null
     * @exception SQLException if a database access error occurs
     */
    public byte[] getBytes(String columnName) throws SQLException {
        return getBytes(findColumn(columnName));
    }

    /**
     * Gets the value of a column in the current row as a java.sql.Date object.
     *
     * @param columnName the SQL name of the column
     * @return the column value; if the value is SQL NULL, the result is null
     * @exception SQLException if a database access error occurs
     */
    public java.sql.Date getDate(String columnName) throws SQLException {
        return getDate(findColumn(columnName));
    }

    /**
     * Gets the value of a column in the current row as a java.sql.Time object.
     *
     * @param columnName the SQL name of the column
     * @return the column value; if the value is SQL NULL, the result is null
     * @exception SQLException if a database access error occurs
     */
    public java.sql.Time getTime(String columnName) throws SQLException {
        return getTime(findColumn(columnName));
    }

    /**
     * Gets the value of a column in the current row as a java.sql.Timestamp object.
     *
     * @param columnName the SQL name of the column
     * @return the column value; if the value is SQL NULL, the result is null
     * @exception SQLException if a database access error occurs
     */
    public java.sql.Timestamp getTimestamp(String columnName) throws SQLException {
        return getTimestamp(findColumn(columnName));
    }

    /**
     * Gets the value of a column in the current row as a stream of
     * ASCII characters. The value can then be read in chunks from the
     * stream. This method is particularly
     * suitable for retrieving large LONGVARCHAR values.  The JDBC driver will
     * do any necessary conversion from the database format into ASCII.
     *
     * <P><B>Note:</B> All the data in the returned stream must be
     * read prior to getting the value of any other column. The next
     * call to a get method implicitly closes the stream. Also, a
     * stream may return 0 when the method <code>available</code>
     * is called whether there is data
     * available or not.
     *
     * @param columnName the SQL name of the column
     * @return a Java input stream that delivers the database column value
     * as a stream of one byte ASCII characters.  If the value is SQL NULL
     * then the result is null.
     * @exception SQLException if a database access error occurs
     */
    public java.io.InputStream getAsciiStream(String columnName) throws SQLException {
        connection.log("ResultSet.getAsciiStream");
        return getAsciiStream(findColumn(columnName));
    }

    /**
     * Gets the value of a column in the current row as a stream of
     * Unicode characters. The value can then be read in chunks from the
     * stream. This method is particularly
     * suitable for retrieving large LONGVARCHAR values.  The JDBC driver will
     * do any necessary conversion from the database format into Unicode.
     * The byte format of the Unicode stream must be Java UTF-8,
     * as defined in the Java Virtual Machine Specification.
     *
     * <P><B>Note:</B> All the data in the returned stream must be
     * read prior to getting the value of any other column. The next
     * call to a get method implicitly closes the stream. Also, a
     * stream may return 0 when the method <code>available</code>
     * is called whether there is data
     * available or not.
     *
     * @param columnName the SQL name of the column
     * @return a Java input stream that delivers the database column value
     * as a stream of two-byte Unicode characters.  If the value is SQL NULL
     * then the result is null.
     * @exception SQLException if a database access error occurs
     * @deprecated
     */
    public java.io.InputStream getUnicodeStream(String columnName) throws SQLException {
        return getUnicodeStream(findColumn(columnName));
    }

    /**
     * Gets the value of a column in the current row as a stream of
     * uninterpreted bytes. The value can then be read in chunks from the
     * stream. This method is particularly
     * suitable for retrieving large LONGVARBINARY values.  The JDBC driver will
     * do any necessary conversion from the database format into uninterpreted
     * bytes.
     *
     * <P><B>Note:</B> All the data in the returned stream must be
     * read prior to getting the value of any other column. The next
     * call to a get method implicitly closes the stream. Also, a
     * stream may return 0 when the method <code>available</code>
     * is called whether there is data
     * available or not.
     *
     * @param columnName the SQL name of the column
     * @return a Java input stream that delivers the database column value
     * as a stream of uninterpreted bytes.  If the value is SQL NULL
     * then the result is null.
     * @exception SQLException if a database access error occurs
     */
    public java.io.InputStream getBinaryStream(String columnName)
            throws SQLException {
        return getBinaryStream(findColumn(columnName));
    }

    //=====================================================================
    // Advanced features:
    //=====================================================================

    /**
     * <p>The first warning reported by calls on this ResultSet is
     * returned. Subsequent ResultSet warnings will be chained to this
     * SQLWarning.
     *
     * <P>The warning chain is automatically cleared each time a new
     * row is read.
     *
     * <P><B>Note:</B> This warning chain only covers warnings caused
     * by ResultSet methods.  Any warning caused by statement methods
     * (such as reading OUT parameters) will be chained on the
     * Statement object. 
     *
     * @return the first SQLWarning or null 
     * @exception SQLException if a database access error occurs
     */
    public SQLWarning getWarnings() throws SQLException {
        connection.log("ResultSet.getWarnings");
        return null;
    }

    /**
     * After this call getWarnings returns null until a new warning is
     * reported for this ResultSet.  
     *
     * @exception SQLException if a database access error occurs
     */
    public void clearWarnings() throws SQLException {
        connection.log("ResultSet.clearWarnings");
    }

    /**
     * Gets the name of the SQL cursor used by this ResultSet.
     *
     * <P>In SQL, a result table is retrieved through a cursor that is
     * named. The current row of a result can be updated or deleted
     * using a positioned update/delete statement that references the
     * cursor name. To insure that the cursor has the proper isolation
     * level to support update, the cursor's select statement should be 
     * of the form 'select for update'. If the 'for update' clause is 
     * omitted the positioned updates may fail.
     *
     * <P>JDBC supports this SQL feature by providing the name of the
     * SQL cursor used by a ResultSet. The current row of a ResultSet
     * is also the current row of this SQL cursor.
     *
     * <P><B>Note:</B> If positioned update is not supported a
     * SQLException is thrown
     *
     * @return the ResultSet's SQL cursor name
     * @exception SQLException if a database access error occurs
     */
    public String getCursorName() throws SQLException {
        connection.log("ResultSet.getCursorName");
        return null;
    }

    /**
     * Retrieves the  number, types and properties of a ResultSet's columns.
     *
     * @return the description of a ResultSet's columns
     * @exception SQLException if a database access error occurs
     */
    public ResultSetMetaData getMetaData() throws SQLException {
        connection.log("ResultSet.getMetaData");
        if (explicitlyClosed)
            ScDBError.check_error(-10, "getMetaData");
        return new ScResultSetMetaData(connection, statement);
    }

    /**
     * JDBC draft specification method for retrieving data as objects.
     * @see java.sql.ResultSet#getObject
     * @exception SQLException in the event of retrieval! error
     * @param column the column desired
     * @param type the SQL data type of the field
     * @scale preceision for Numerics
     * @return the column specified as an Object
     */

    public Object getObject(int column, int type, int scale)
            throws SQLException {
        connection.log("ResultSet.getObject");
        currentColIndex = column;

        //jiaq, 04/14/2003
        if (this.wasNull()) return null;

        switch (type) {
            case Types.BIT:
                return new Boolean(getBoolean(column));

            case Types.TINYINT:
                return new Integer(getInt(column));

            case Types.SMALLINT:
                return new Integer(getShort(column));

            case Types.INTEGER:
                return new Integer(getInt(column));

            case Types.BIGINT:
                return new Long(getLong(column));

            case Types.FLOAT:
                return new Float(getFloat(column));

            case Types.REAL:
                return new Float(getFloat(column));

            case Types.DOUBLE:
                return new Double(getDouble(column));

            case Types.BLOB:
                return getBlob(column);

            //case Types.NUMERIC:
            //return getNumeric(column, scale);

            //case Types.DECIMAL:
            //return getNumeric(column, scale);

            case Types.CHAR:
                return getString(column);

            case Types.VARCHAR:
                return getString(column);

            case Types.LONGVARCHAR:
                return getString(column);

            case Types.DATE:
                return getDate(column);

            case Types.TIME:
                return getTime(column);

            case Types.TIMESTAMP:
                return getTimestamp(column);

            case Types.BINARY:
                return getBytes(column);

            case Types.VARBINARY:
                return getBytes(column);

            case Types.LONGVARBINARY:
                return getBytes(column);

            case 99:
            case Types.DECIMAL:
            case Types.NUMERIC:
                return new BigDecimal(getString(column));

            default:
                return statement.cells.elementAt(statement.i_iCurrentRow - 1, column - 1);
        }
    }

    /**
     * <p>Gets the value of a column in the current row as a Java object.
     *
     * <p>This method will return the value of the given column as a
     * Java object.  The type of the Java object will be the default
     * Java object type corresponding to the column's SQL type,
     * following the mapping for built-in types specified in the JDBC 
     * spec.
     *
     * <p>This method may also be used to read datatabase-specific
     * abstract data types.
     *
     * JDBC 2.0
     *
     *
     * In the JDBC 2.0 API, the behavior of method
     * <code>getObject</code> is extended to materialize
     * data of SQL user-defined types.  When the a column contains
     * a structured or distinct value, the behavior of this method is as 
     * if it were a call to: getObject(columnIndex, 
     * this.getStatement().getConnection().getTypeMap()).
     *
     * @param columnIndex the first column is 1, the second is 2, ...
     * @return a java.lang.Object holding the column value  
     * @exception SQLException if a database access error occurs
     */
    public Object getObject(int columnIndex) throws SQLException {
        connection.log("ResultSet.getObject");
        //ResultSetMetaData meta = getMetaData();
        int type = getColumnType(columnIndex);

        return getObject(columnIndex, type, 0);
    }

    /**
     * <p>Gets the value of a column in the current row as a Java object.
     *
     * <p>This method will return the value of the given column as a
     * Java object.  The type of the Java object will be the default
     * Java object type corresponding to the column's SQL type,
     * following the mapping for built-in types specified in the JDBC 
     * spec.
     *
     * <p>This method may also be used to read datatabase-specific
     * abstract data types.
     *
     * JDBC 2.0
     *
     * In the JDBC 2.0 API, the behavior of method
     * <code>getObject</code> is extended to materialize
     * data of SQL user-defined types.  When the a column contains
     * a structured or distinct value, the behavior of this method is as 
     * if it were a call to: getObject(columnIndex, 
     * this.getStatement().getConnection().getTypeMap()).
     *
     * @param columnName the SQL name of the column
     * @return a java.lang.Object holding the column value.  
     * @exception SQLException if a database access error occurs
     */
    public Object getObject(String columnName) throws SQLException {
        return getObject(findColumn(columnName));
    }

    //----------------------------------------------------------------

    /**
     * Maps the given Resultset column name to its ResultSet column index.
     *
     * @param columnName the name of the column
     * @return the column index
     * @exception SQLException if a database access error occurs
     */
    public int findColumn(String columnName) throws SQLException {
        connection.log("ResultSet.findColumn(" + columnName + ")");
        if (statement.i_ahHash == null) {
            Object[] obj = {columnName};
            throw new java.sql.SQLException(ScBundle.getMessage(ScResourceKeys.Invalid_column, obj));
        }
        columnName = columnName.toUpperCase().trim();

        Integer o;
        String s;
        Enumeration enum1 = statement.i_ahHash.keys();
        while (enum1.hasMoreElements()) {
            o = (Integer) enum1.nextElement();
            String sTemp = (String) statement.i_ahHash.get(o);
            if (columnName.indexOf('.') < 0) {
                s = (sTemp.trim().substring(sTemp.indexOf('.') + 1, sTemp.trim().length()));
                if (s.equalsIgnoreCase(columnName)) return o.intValue();
            } else if (sTemp.trim().equalsIgnoreCase(columnName)) return o.intValue();

        }
        Object[] obj = {columnName};
        throw new java.sql.SQLException(ScBundle.getMessage(ScResourceKeys.Invalid_column, obj));
    }

    //--------------------------JDBC 2.0-----------------------------------

    //---------------------------------------------------------------------
    // Getter's and Setter's
    //---------------------------------------------------------------------

    /**
     * JDBC 2.0
     *
     * <p>Gets the value of a column in the current row as a java.io.Reader.
     * @param columnIndex the first column is 1, the second is 2, ...
     */
    public java.io.Reader getCharacterStream(int columnIndex) throws SQLException {
        connection.log("ResultSet.getCharacterStream");
        currentColIndex = columnIndex;
        java.io.Reader charStream = null;
        String asTemp = (String) statement.cells.elementAt(statement.i_iCurrentRow - 1, columnIndex - 1);
        if (asTemp == null) return null;

        if (isBinary(getColumnType(columnIndex))) {
            Object obj = getObject(columnIndex);
            if (obj == null)
                return null;
            charStream = new java.io.InputStreamReader(new ByteArrayInputStream((byte[]) obj));
        } else if (isString(getColumnType(columnIndex))) {
            Object obj1 = getObject(columnIndex);
            if (obj1 == null)
                return null;
            charStream = new java.io.StringReader(obj1.toString());
        } else {
            throw new SQLException(ScBundle.getMessage(ScResourceKeys.Data_type_mismatch));
        }
        return charStream;


    }

    /**
     * JDBC 2.0
     *
     * <p>Gets the value of a column in the current row as a java.io.Reader.
     * @param columnName the name of the column
     * @return the value in the specified column as a <code>java.io.Reader</code>
     */
    public java.io.Reader getCharacterStream(String columnName) throws SQLException {
        return getCharacterStream(findColumn(columnName));
    }

    /**
     * JDBC 2.0
     *
     * Gets the value of a column in the current row as a java.math.BigDecimal 
     * object with full precision.
     *
     * @param columnIndex the first column is 1, the second is 2, ...
     * @return the column value (full precision); if the value is SQL NULL, 
     * the result is null
     * @exception SQLException if a database access error occurs
     *
     * @history - thoniyilmk - 11/21/2003 - CR 7176
     * 		This function was returning a 0 (zero), everytime called.
     * 		Removing the getLong() function, as it doesn't accept a decimal value
     * 		and throws an exception.
     * @history - thoniyilmk - 12/10/2003 - CR 7176
     * 		Modified the function to return a formatted number. A value "500", was
     * 		returned as it is. Now, it formats to "500.00".
     * @history - thoniyilmk - 12/18/2003 - CR 7766
     * 		Modified the function to look for precision in the meta data and set the
     * 		decimal point, accordingly. So, for a column with no decimal points (numeric),
     *  	there won't be any default zeros added to it.
     * @history - thoniyilmk - 01/27/2004 - CR 8054
     * 		This function was returning a 0 or 0.00 for a SQL NULL from the database.
     *  	This function is suppose to return a NULL value, if a SQL NULL is received 
     * 		from the database. A check was made at the	beginning of the function to 
     * 		see if the value is NULL. If so, a NULL	is returned.
     */
    public BigDecimal getBigDecimal(int columnIndex) throws SQLException {
        connection.log("ResultSet.getBigDecimal");
        currentColIndex = columnIndex;
        if (this.wasNull()) return null;
        if (statement.i_iTotalRows == 0) return BigDecimal.valueOf(0);
        String asTemp = (String) statement.cells.elementAt(statement.i_iCurrentRow - 1, columnIndex - 1);
        if ((asTemp == null) || (asTemp.length() == 0))
            asTemp = "0";
        ResultSetMetaData rsmd = this.getMetaData();
        int iScale = rsmd.getPrecision(columnIndex);

        BigDecimal bdecimal = new BigDecimal(asTemp);
        if (iScale > 0) {
            return bdecimal.setScale(iScale);
        }
        return bdecimal;
    }

    /**
     * JDBC 2.0
     *
     * Gets the value of a column in the current row as a java.math.BigDecimal 
     * object with full precision.4
     * @param columnName the column name
     * @return the column value (full precision); if the value is SQL NULL, 
     * the result is null
     * @exception SQLException if a database access error occurs
     *
     */
    public BigDecimal getBigDecimal(String columnName) throws SQLException {
        return getBigDecimal(findColumn(columnName));
    }

    //---------------------------------------------------------------------
    // Traversal/Positioning
    //---------------------------------------------------------------------

    /**
     * JDBC 2.0
     *
     * <p>Indicates whether the cursor is before the first row in the result 
     * set.   
     *
     * @return true if the cursor is before the first row, false otherwise. Returns
     * false when the result set contains no rows.
     * @exception SQLException if a database access error occurs
     */
    public boolean isBeforeFirst() throws SQLException {
        connection.log("ResultSet.isBeforeFirst");
        if (statement.i_iCurrentRow == 0) return true;
        else return false;
    }

    /**
     * JDBC 2.0
     *
     * <p>Indicates whether the cursor is after the last row in the result 
     * set.   
     *
     * @return true if the cursor is  after the last row, false otherwise.  Returns
     * false when the result set contains no rows.
     * @exception SQLException if a database access error occurs
     */
    public boolean isAfterLast() throws SQLException {
        connection.log("ResultSet.isAfterLast");
        if ((statement.i_iCurrentRow > statement.i_iTotalRows) && (closed == true)) return true;
        return false;
    }

    /**
     * JDBC 2.0
     *
     * <p>Indicates whether the cursor is on the first row of the result set.   
     *
     * @return true if the cursor is on the first row, false otherwise.   
     * @exception SQLException if a database access error occurs
     */
    public boolean isFirst() throws SQLException {
        connection.log("ResultSet.isFirst");
        if (statement.i_iCurrentRow == 1) return true;
        else return false;
    }

    /**
     * JDBC 2.0
     *
     * <p>Indicates whether the cursor is on the last row of the result set.   
     * Note: Calling the method <code>isLast</code> may be expensive
     * because the JDBC driver
     * might need to fetch ahead one row in order to determine 
     * whether the current row is the last row in the result set.
     *
     * @return true if the cursor is on the last row, false otherwise. 
     * @exception SQLException if a database access error occurs
     */
    public boolean isLast() throws SQLException {
        connection.log("ResultSet.isLast");
        if ((statement.gotLastBatch) && (statement.i_iCurrentRow == statement.cells.rows())) return true;
        return false;
    }

    /**
     * JDBC 2.0
     *
     * <p>Moves the cursor to the front of the result set, just before the
     * first row. Has no effect if the result set contains no rows.
     *
     * @exception SQLException if a database access error occurs or the 
     * result set type is TYPE_FORWARD_ONLY
     */
    public void beforeFirst() throws SQLException {
        connection.log("ResultSet.beforeFirst");
        if (statement.resultSetType == ResultSet.TYPE_FORWARD_ONLY)
            ScDBError.check_error(262);
        statement.i_iCurrentRow = 0;
        closed = false;
    }

    /**
     * JDBC 2.0
     *
     * <p>Moves the cursor to the end of the result set, just after the last
     * row.  Has no effect if the result set contains no rows.
     *
     * @exception SQLException if a database access error occurs or the 
     * result set type is TYPE_FORWARD_ONLY 
     */
    public void afterLast() throws SQLException {
        connection.log("ResultSet.afterLast");
        if (statement.resultSetType == ResultSet.TYPE_FORWARD_ONLY)
            ScDBError.check_error(262);
        last();
        statement.i_iCurrentRow = statement.i_iTotalRows + 1;
        closed = true;
    }

    /**
     * JDBC 2.0
     *
     * <p>Moves the cursor to the first row in the result set.  
     *
     * @return true if the cursor is on a valid row; false if
     *         there are no rows in the result set
     * @exception SQLException if a database access error occurs or the 
     * result set type is TYPE_FORWARD_ONLY
     */
    public boolean first() throws SQLException {
        connection.log("ResultSet.first");
        if (statement.resultSetType == ResultSet.TYPE_FORWARD_ONLY)
            ScDBError.check_error(262);

        if (statement.cells.rows() == 0) return false;
        statement.i_iCurrentRow = 1;
        closed = false;
        return true;
    }

    /**
     * JDBC 2.0
     *
     * <p>Moves the cursor to the last row in the result set.  
     *
     * @return true if the cursor is on a valid row;
     * false if there are no rows in the result set
     * @exception SQLException if a database access error occurs or the
     * result set type is TYPE_FORWARD_ONLY.
     */
    public boolean last() throws SQLException {
        connection.log("ResultSet.last");
        if (statement.resultSetType == ResultSet.TYPE_FORWARD_ONLY)
            ScDBError.check_error(262);
        if ((statement.cells.rows() == 0) || (statement.gotLastBatch)) return false;

        try {
            do {
                int queryRows = connection.i_dDbAccess.fetch(i_dBStatement);
                if (queryRows > 0) statement.add(i_dBStatement);
                if (((ScMsqlQueryStatement) i_dBStatement).getSqlStatus().equals("01500"))
                    statement.gotLastBatch = true;
            }
            while (!statement.gotLastBatch);
        } catch (Exception e) {
            ScDBError.check_error(e);
        }
        statement.i_iCurrentRow = statement.cells.rows();
        closed = false;

        return true;
    }

    /**
     * JDBC 2.0
     *
     * <p>Retrieves the current row number.  The first row is number 1, the
     * second number 2, and so on.  
     *
     * @return the current row number; 0 if there is no current row
     * @exception SQLException if a database access error occurs
     */
    public int getRow() throws SQLException {
        connection.log("ResultSet.getRow");
        return statement.i_iCurrentRow;
    }

    /**
     * JDBC 2.0
     *
     * <p>Moves the cursor to the given row number in the result set.
     *
     * <p>If the row number is positive, the cursor moves to 
     * the given row number with respect to the
     * beginning of the result set.  The first row is row 1, the second
     * is row 2, and so on. 
     *
     * <p>If the given row number is negative, the cursor moves to
     * an absolute row position with respect to
     * the end of the result set.  For example, calling
     * <code>absolute(-1)</code> positions the
     * cursor on the last row, <code>absolute(-2)</code> indicates the next-to-last
     * row, and so on.
     *
     * <p>An attempt to position the cursor beyond the first/last row in
     * the result set leaves the cursor before/after the first/last
     * row, respectively.
     *
     * <p>Note: Calling <code>absolute(1)</code> is the same
     * as calling <code>first()</code>.
     * Calling <code>absolute(-1)</code> is the same as calling <code>last()</code>.
     *
     * @return true if the cursor is on the result set; false otherwise
     * @exception SQLException if a database access error occurs or 
     * row is 0, or result set type is TYPE_FORWARD_ONLY.
     */
    public boolean absolute(int row) throws SQLException {
        connection.log("ResultSet.absolute");
        if (statement.resultSetType == ResultSet.TYPE_FORWARD_ONLY)
            ScDBError.check_error(262);

        if (statement.cells.rows() == 0) return false;
        if (row < 0) {
            last();
            row = statement.i_iTotalRows + 1 + row;
            if (row < 0) return false;
        }

        if (row <= statement.i_iTotalRows) {
            statement.i_iCurrentRow = row;
            closed = false;
            return true;
        }

        if ((row > statement.i_iTotalRows) && (statement.gotLastBatch)) return false;

        try {
            do {
                int queryRows = connection.i_dDbAccess.fetch(i_dBStatement);
                statement.add(i_dBStatement);
                if (((ScMsqlQueryStatement) i_dBStatement).getSqlStatus().equals("01500"))
                    statement.gotLastBatch = true;

            }
            while (!statement.gotLastBatch);
        } catch (Exception e) {
            ScDBError.check_error(e);
        }

        if (row > statement.i_iTotalRows) {
            internalClose();
            return false;
        }

        statement.i_iCurrentRow = row;
        closed = false;
        return true;
    }

    /**
     * JDBC 2.0
     *
     * <p>Moves the cursor a relative number of rows, either positive or negative.
     * Attempting to move beyond the first/last row in the
     * result set positions the cursor before/after the
     * the first/last row. Calling <code>relative(0)</code> is valid, but does
     * not change the cursor position.
     *
     * <p>Note: Calling <code>relative(1)</code>
     * is different from calling <code>next()</code>
     * because is makes sense to call <code>next()</code> when there is no current row,
     * for example, when the cursor is positioned before the first row
     * or after the last row of the result set.
     *
     * @return true if the cursor is on a row; false otherwise
     * @exception SQLException if a database access error occurs, there
     * is no current row, or the result set type is TYPE_FORWARD_ONLY
     */
    public boolean relative(int rows) throws SQLException {
        connection.log("ResultSet.relative");
        if (statement.resultSetType == ResultSet.TYPE_FORWARD_ONLY)
            ScDBError.check_error(262);
        return absolute(statement.i_iCurrentRow + rows);
    }

    /**
     * JDBC 2.0
     *
     * <p>Moves the cursor to the previous row in the result set.  
     *
     * <p>Note: <code>previous()</code> is not the same as
     * <code>relative(-1)</code> because it
     * makes sense to call</code>previous()</code> when there is no current row.
     *
     * @return true if the cursor is on a valid row; false if it is off the result set
     * @exception SQLException if a database access error occurs or the
     * result set type is TYPE_FORWARD_ONLY
     */
    public boolean previous() throws SQLException {
        connection.log("ResultSet.previous");
        if (statement.resultSetType == ResultSet.TYPE_FORWARD_ONLY)
            ScDBError.check_error(262);
        if (statement.i_iTotalRows == 0) return false;
        if (statement.i_iCurrentRow == 0) return true;
        statement.i_iCurrentRow--;
        closed = false;
        return true;
    }

    //---------------------------------------------------------------------
    // Properties
    //---------------------------------------------------------------------

    /**
     * JDBC 2.0
     *
     * The rows in a result set will be processed in a forward direction;
     * first-to-last.
     */
    int FETCH_FORWARD = 1000;

    /**
     * JDBC 2.0
     *
     * The rows in a result set will be processed in a reverse direction;
     * last-to-first.
     */
    int FETCH_REVERSE = 1001;

    /**
     * JDBC 2.0
     *
     * The order in which rows in a result set will be processed is unknown.
     */
    int FETCH_UNKNOWN = 1002;

    /**
     * JDBC 2.0
     *
     * Gives a hint as to the direction in which the rows in this result set
     * will be processed.  The initial value is determined by the statement
     * that produced the result set.  The fetch direction may be changed
     * at any time.
     *
     * @exception SQLException if a database access error occurs or
     * the result set type is TYPE_FORWARD_ONLY and the fetch direction is not 
     * FETCH_FORWARD.
     */
    public void setFetchDirection(int direction) throws SQLException {

        connection.log("ResultSet.setFetchDirection");
        if (direction != ResultSet.FETCH_FORWARD)
            throw new SQLException(ScBundle.getMessage(ScResourceKeys.TYPE_FORWARD_ONLY_Result));
        this.fetchDirection = direction;
    }


    /**
     * JDBC 2.0
     *
     * Returns the fetch direction for this result set.
     *
     * @return the current fetch direction for this result set
     * @exception SQLException if a database access error occurs
     */
    public int getFetchDirection() throws SQLException {
        connection.log("ResultSet.getFetchDirection");
        return this.fetchDirection;
    }

    /**
     * JDBC 2.0
     *
     * Gives the JDBC driver a hint as to the number of rows that should 
     * be fetched from the database when more rows are needed for this result
     * set.  If the fetch size specified is zero, the JDBC driver 
     * ignores the value and is free to make its own best guess as to what
     * the fetch size should be.  The default value is set by the statement 
     * that created the result set.  The fetch size may be changed at any 
     * time.
     *
     * @param rows the number of rows to fetch
     * @exception SQLException if a database access error occurs or the
     * condition 0 <= rows <= this.getMaxRows() is not satisfied.
     */
    /**
     * setFetchSize had no check to validate the invalid rows set
     * Incorporated the validation:
     */
    public void setFetchSize(int rows) throws SQLException {
        connection.log("ResultSet.setFetchSize");
        if (rows < 0 || (statement.maxRows != 0 && rows > statement.maxRows))
            ScDBError.check_error(-63, "" + rows);
        ((ScMsqlQueryStatement) this.i_dBStatement).sqlQuailfier = "ROWS=" + String.valueOf(rows);

    }

    /**
     * JDBC 2.0
     *
     * Returns the fetch size for this result set.
     *
     * @return the current fetch size for this result set
     * @exception SQLException if a database access error occurs
     */
    /**
     * The keyword ROWS can be the first word in some cases 
     */
    public int getFetchSize() throws SQLException {
        connection.log("ResultSet.getFetchSize");
        String fetchSize = ((ScMsqlQueryStatement) this.i_dBStatement).sqlQuailfier;
        if (fetchSize.indexOf("ROWS") >= 0) {
            fetchSize = fetchSize.substring(fetchSize.indexOf("=") + 1, fetchSize.length());
            return Integer.parseInt(fetchSize.trim());
        } else return connection.i_iDefaultRowPrefetch;
    }

    /**
     * JDBC 2.0
     * The type for a <code>ResultSet</code> object whose cursor may
     * move only forward.
     */
    int TYPE_FORWARD_ONLY = 1003;

    /**
     * JDBC 2.0
     * The type for a <code>ResultSet</code> object that is scrollable
     * but generally not sensitive to changes made by others.
     *
     */
    int TYPE_SCROLL_INSENSITIVE = 1004;

    /**
     * JDBC 2.0
     * The type for a <code>ResultSet</code> object that is scrollable
     * and generally sensitive to changes made by others.
     */
    int TYPE_SCROLL_SENSITIVE = 1005;

    /**
     * JDBC 2.0
     *
     * Returns the type of this result set.  The type is determined by
     * the statement that created the result set.
     *
     * @return TYPE_FORWARD_ONLY, TYPE_SCROLL_INSENSITIVE, or
     * TYPE_SCROLL_SENSITIVE
     * @exception SQLException if a database access error occurs
     */
    public int getType() throws SQLException {
        connection.log("ResultSet.getType");
        return statement.resultSetType;
    }

    /**
     * JDBC 2.0
     * The concurrency mode for a <code>ResultSet</code> object
     * that may NOT be updated.
     *
     */
    int CONCUR_READ_ONLY = 1007;

    /**
     * JDBC 2.0
     * The concurrency mode for a <code>ResultSet</code> object
     * that may be updated.
     *
     */
    int CONCUR_UPDATABLE = 1008;

    /**
     * JDBC 2.0
     *
     * Returns the concurrency mode of this result set.  The concurrency
     * used is determined by the statement that created the result set.
     *
     * @return the concurrency type, CONCUR_READ_ONLY or CONCUR_UPDATABLE
     * @exception SQLException if a database access error occurs
     */
    public int getConcurrency() throws SQLException {
        connection.log("ResultSet.getConcurrency");
        return statement.resultSetConcurrency;
    }

    //---------------------------------------------------------------------
    // Updates
    //---------------------------------------------------------------------

    /**
     * JDBC 2.0
     *
     * Indicates whether the current row has been updated.  The value returned 
     * depends on whether or not the result set can detect updates.
     *
     * @return true if the row has been visibly updated by the owner or
     * another, and updates are detected
     * @exception SQLException if a database access error occurs
     *
     * @see DatabaseMetaData#updatesAreDetected
     */
    public boolean rowUpdated() throws SQLException {
       /*
       connection.log("ResultSet.rowUpdated");
       int oldCurrentRow  = statement.i_iCurrentRow;
       Object[] o = statement.copyDesc[oldCurrentRow-1];
       refreshRow();
       statement.i_iCurrentRow = oldCurrentRow;
       for (int i=0; i<statement.i_ahHash.size();i++)
       {
            if (!o[i].equals(statement.copyDesc[oldCurrentRow-1][i])) return true;
       }
       */
        return false;
    }

    /**
     * JDBC 2.0
     *
     * Indicates whether the current row has had an insertion.  The value returned 
     * depends on whether or not the result set can detect visible inserts.
     *
     * @return true if a row has had an insertion and insertions are detected
     * @exception SQLException if a database access error occurs
     *
     * @see DatabaseMetaData#insertsAreDetected
     */
    public boolean rowInserted() throws SQLException {
        connection.log("ResultSet.rowInserted");
        return false;
    }

    /**
     * JDBC 2.0
     *
     * Indicates whether a row has been deleted.  A deleted row may leave
     * a visible "hole" in a result set.  This method can be used to
     * detect holes in a result set.  The value returned depends on whether 
     * or not the result set can detect deletions.
     *
     * @return true if a row was deleted and deletions are detected
     * @exception SQLException if a database access error occurs
     *
     * @see DatabaseMetaData#deletesAreDetected
     */
    public boolean rowDeleted() throws SQLException {
        connection.log("ResultSet.rowDeleted");
        return false;
    }

    /**
     * JDBC 2.0
     *
     * Give a nullable column a null value.
     *
     * The <code>updateXXX</code> methods are used to update column values in the
     * current row, or the insert row.  The <code>updateXXX</code> methods do not 
     * update the underlying database; instead the <code>updateRow</code> or <code>insertRow</code>
     * methods are called to update the database.
     *
     * @param columnIndex the first column is 1, the second is 2, ...
     * @exception SQLException if a database access error occurs
     */
    public void updateNull(int columnIndex) throws SQLException {
        connection.log("ResultSet.updateNull");
        updateString(columnIndex, null);
    }

    /**
     * JDBC 2.0
     *
     * Updates a column with a boolean value.
     *
     * The <code>updateXXX</code> methods are used to update column values in the
     * current row, or the insert row.  The <code>updateXXX</code> methods do not 
     * update the underlying database; instead the <code>updateRow</code> or <code>insertRow</code>
     * methods are called to update the database.
     *
     * @param columnIndex the first column is 1, the second is 2, ...
     * @param x the new column value
     * @exception SQLException if a database access error occurs
     */
    public void updateBoolean(int columnIndex, boolean x) throws SQLException {
        connection.log("ResultSet.updateBoolean");
        String x1 = "";
        if (x == true) x1 = "1";
        else x1 = "0";
        updateString(columnIndex, x1);
    }

    /**
     * JDBC 2.0
     *
     * Updates a column with a byte value.
     *
     * The <code>updateXXX</code> methods are used to update column values in the
     * current row, or the insert row.  The <code>updateXXX</code> methods do not 
     * update the underlying database; instead the <code>updateRow</code> or <code>insertRow</code>
     * methods are called to update the database.
     *
     * @param columnIndex the first column is 1, the second is 2, ...
     * @param x the new column value
     * @exception SQLException if a database access error occurs
     */
    public void updateByte(int columnIndex, byte x) throws SQLException {
        connection.log("ResultSet.updateByte");
        updateString(columnIndex, String.valueOf((char) x));
    }

    /**
     * JDBC 2.0
     *
     * Updates a column with a short value.
     *
     * The <code>updateXXX</code> methods are used to update column values in the
     * current row, or the insert row.  The <code>updateXXX</code> methods do not 
     * update the underlying database; instead the <code>updateRow</code> or <code>insertRow</code>
     * methods are called to update the database.
     *
     * @param columnIndex the first column is 1, the second is 2, ...
     * @param x the new column value
     * @exception SQLException if a database access error occurs
     */
    public void updateShort(int columnIndex, short x) throws SQLException {
        connection.log("ResultSet.updateShort");
        updateString(columnIndex, String.valueOf(x));
    }

    /**
     * JDBC 2.0
     *
     * Updates a column with an integer value.
     *
     * The <code>updateXXX</code> methods are used to update column values in the
     * current row, or the insert row.  The <code>updateXXX</code> methods do not 
     * update the underlying database; instead the <code>updateRow</code> or <code>insertRow</code>
     * methods are called to update the database.
     *
     * @param columnIndex the first column is 1, the second is 2, ...
     * @param x the new column value
     * @exception SQLException if a database access error occurs
     */
    public void updateInt(int columnIndex, int x) throws SQLException {
        connection.log("ResultSet.updateInt");
        updateString(columnIndex, String.valueOf(x));
    }

    /**
     * JDBC 2.0
     *
     * Updates a column with a long value.
     *
     * The <code>updateXXX</code> methods are used to update column values in the
     * current row, or the insert row.  The <code>updateXXX</code> methods do not 
     * update the underlying database; instead the <code>updateRow</code> or <code>insertRow</code>
     * methods are called to update the database.
     *
     * @param columnIndex the first column is 1, the second is 2, ...
     * @param x the new column value
     * @exception SQLException if a database access error occurs
     */
    public void updateLong(int columnIndex, long x) throws SQLException {
        connection.log("ResultSet.updateLong");
        updateString(columnIndex, String.valueOf(x));
    }

    /**
     * JDBC 2.0
     *
     * Updates a column with a float value.
     *
     * The <code>updateXXX</code> methods are used to update column values in the
     * current row, or the insert row.  The <code>updateXXX</code> methods do not 
     * update the underlying database; instead the <code>updateRow</code> or <code>insertRow</code>
     * methods are called to update the database.
     *
     * @param columnIndex the first column is 1, the second is 2, ...
     * @param x the new column value
     * @exception SQLException if a database access error occurs
     */
    public void updateFloat(int columnIndex, float x) throws SQLException {
        connection.log("ResultSet.updateFloat");
        updateString(columnIndex, String.valueOf(x));
    }

    /**
     * JDBC 2.0
     *
     * Updates a column with a Double value.
     *
     * The <code>updateXXX</code> methods are used to update column values in the
     * current row, or the insert row.  The <code>updateXXX</code> methods do not 
     * update the underlying database; instead the <code>updateRow</code> or <code>insertRow</code>
     * methods are called to update the database.
     *
     * @param columnIndex the first column is 1, the second is 2, ...
     * @param x the new column value
     * @exception SQLException if a database access error occurs
     */
    public void updateDouble(int columnIndex, double x) throws SQLException {
        connection.log("ResultSet.updateDouble");
        updateString(columnIndex, String.valueOf(x));
    }

    /**
     * JDBC 2.0
     *
     * Updates a column with a BigDecimal value.
     *
     * The <code>updateXXX</code> methods are used to update column values in the
     * current row, or the insert row.  The <code>updateXXX</code> methods do not 
     * update the underlying database; instead the <code>updateRow</code> or <code>insertRow</code>
     * methods are called to update the database.
     *
     * @param columnIndex the first column is 1, the second is 2, ...
     * @param x the new column value
     * @exception SQLException if a database access error occurs
     */
    public void updateBigDecimal(int columnIndex, BigDecimal x) throws SQLException {
        connection.log("ResultSet.updateBigDecimal");
        long v = x.longValue();
        updateString(columnIndex, String.valueOf(v));
    }

    /**
     * JDBC 2.0
     *
     * Updates a column with a String value.
     *
     * The <code>updateXXX</code> methods are used to update column values in the
     * current row, or the insert row.  The <code>updateXXX</code> methods do not 
     * update the underlying database; instead the <code>updateRow</code> or <code>insertRow</code>
     * methods are called to update the database.
     *
     * @param columnIndex the first column is 1, the second is 2, ...
     * @param x the new column value
     * @exception SQLException if a database access error occurs
     */
    public void updateString(int columnIndex, String x) throws SQLException {
        connection.log("ResultSet.updateString");
        if (statement.resultSetConcurrency == ResultSet.CONCUR_READ_ONLY) {
            ScDBError.check_error(257);
            return;
        }
        verify(columnIndex);
        statement.cells.updateElement(statement.i_iCurrentRow - 1, columnIndex - 1, x);


    }

    /**
     * JDBC 2.0
     *
     * Updates a column with a byte array value.
     *
     * The <code>updateXXX</code> methods are used to update column values in the
     * current row, or the insert row.  The <code>updateXXX</code> methods do not 
     * update the underlying database; instead the <code>updateRow</code> or <code>insertRow</code>
     * methods are called to update the database.
     *
     * @param columnIndex the first column is 1, the second is 2, ...
     * @param x the new column value
     * @exception SQLException if a database access error occurs
     */
    public void updateBytes(int columnIndex, byte x[]) throws SQLException {
        connection.log("ResultSet.updateBytes");
        updateString(columnIndex, new String(x));
    }

    /**
     * JDBC 2.0
     *
     * Updates a column with a Date value.
     *
     * The <code>updateXXX</code> methods are used to update column values in the
     * current row, or the insert row.  The <code>updateXXX</code> methods do not 
     * update the underlying database; instead the <code>updateRow</code> or <code>insertRow</code>
     * methods are called to update the database.
     *
     * @param columnIndex the first column is 1, the second is 2, ...
     * @param x the new column value
     * @exception SQLException if a database access error occurs
     */
    public void updateDate(int columnIndex, java.sql.Date x) throws SQLException {
        connection.log("ResultSet.updateDate");
        updateString(columnIndex, ScUtility.JavaDateToJulianDate(x));
    }

    /**
     * JDBC 2.0
     *
     * Updates a column with a Time value.
     *
     * The <code>updateXXX</code> methods are used to update column values in the
     * current row, or the insert row.  The <code>updateXXX</code> methods do not 
     * update the underlying database; instead the <code>updateRow</code> or <code>insertRow</code>
     * methods are called to update the database.
     *
     * @param columnIndex the first column is 1, the second is 2, ...
     * @param x the new column value
     * @exception SQLException if a database access error occurs
     */
    public void updateTime(int columnIndex, java.sql.Time x) throws SQLException {
        connection.log("ResultSet.updateTime");
        updateString(columnIndex, ScUtility.JavaTimeToJulianTime(x));
    }

    /**
     * JDBC 2.0
     *
     * Updates a column with a Timestamp value.
     *
     * The <code>updateXXX</code> methods are used to update column values in the
     * current row, or the insert row.  The <code>updateXXX</code> methods do not 
     * update the underlying database; instead the <code>updateRow</code> or <code>insertRow</code>
     * methods are called to update the database.
     *
     * @param columnIndex the first column is 1, the second is 2, ...
     * @param x the new column value
     * @exception SQLException if a database access error occurs
     */
    public void updateTimestamp(int columnIndex, java.sql.Timestamp x)
            throws SQLException {
        connection.log("ResultSet.updateTimestamp");
    }

    /**
     * JDBC 2.0
     *
     * Updates a column with an ascii stream value.
     *
     * The <code>updateXXX</code> methods are used to update column values in the
     * current row, or the insert row.  The <code>updateXXX</code> methods do not 
     * update the underlying database; instead the <code>updateRow</code> or <code>insertRow</code>
     * methods are called to update the database.
     *
     * @param columnIndex the first column is 1, the second is 2, ...
     * @param x the new column value
     * @param length the length of the stream
     * @exception SQLException if a database access error occurs
     */
    public void updateAsciiStream(int columnIndex,
                                  java.io.InputStream x,
                                  int length) throws SQLException {
        connection.log("ResultSet.updateAsciiStream");
        ScDBError.check_error(-52, "ResultSet.updateAsciiStream");
    }


    /**
     * JDBC 2.0
     *
     * Updates a column with a binary stream value.
     *
     * The <code>updateXXX</code> methods are used to update column values in the
     * current row, or the insert row.  The <code>updateXXX</code> methods do not 
     * update the underlying database; instead the <code>updateRow</code> or <code>insertRow</code>
     * methods are called to update the database.
     *
     * @param columnIndex the first column is 1, the second is 2, ...
     * @param x the new column value     
     * @param length the length of the stream
     * @exception SQLException if a database access error occurs
     */
    public void updateBinaryStream(int parameterIndex,
                                   java.io.InputStream inputstream,
                                   int j) throws SQLException {
        connection.log("ResultSet.updateBinaryStream");
        verify(parameterIndex);

        // Read in the entire InputStream all at once.  A more optimal
        // way of handling this would be to defer the read until execute
        // time, and only read in chunks at a time.

        if (!isBinary(getColumnType(parameterIndex)))
            throw new SQLException(ScBundle.getMessage(ScResourceKeys.Data_type_mismatch));
        byte abyte0[] = new byte[j];
        try {
            int k = 0;
            do
                k += inputstream.read(abyte0, k, j - k);
            while (k != -1);
        } catch (java.io.IOException _ex) {
            throw new SQLException(ScBundle.getMessage(ScResourceKeys.Read_failed));
        }

        updateBytes(parameterIndex, abyte0);
    }

    /**
     * JDBC 2.0
     *
     * Updates a column with a character stream value.
     *
     * The <code>updateXXX</code> methods are used to update column values in the
     * current row, or the insert row.  The <code>updateXXX</code> methods do not 
     * update the underlying database; instead the <code>updateRow</code> or <code>insertRow</code>
     * methods are called to update the database.
     *
     * @param columnIndex the first column is 1, the second is 2, ...
     * @param x the new column value
     * @param length the length of the stream
     * @exception SQLException if a database access error occurs
     */
    public void updateCharacterStream(int columnIndex,
                                      java.io.Reader reader,
                                      int j) throws SQLException {
        connection.log("ResultSet.updateCharacterStream");

        if (!isString(getColumnType(columnIndex)) && !isBinary(getColumnType(columnIndex)))
            throw new SQLException(ScBundle.getMessage(ScResourceKeys.Data_type_mismatch));
        char ac[] = new char[j];
        try {
            int k = 0;
            do
                k += reader.read(ac, k, j - k);
            while (k != -1);
        } catch (java.io.IOException _ex) {
            throw new SQLException(ScBundle.getMessage(ScResourceKeys.Read_failed));
        }
        String s = new String(ac);

        updateString(columnIndex, s);
    }

    /**
     * JDBC 2.0
     *
     * Updates a column with an Object value.
     *
     * The <code>updateXXX</code> methods are used to update column values in the
     * current row, or the insert row.  The <code>updateXXX</code> methods do not 
     * update the underlying database; instead the <code>updateRow</code> or <code>insertRow</code>
     * methods are called to update the database.
     *
     * @param columnIndex the first column is 1, the second is 2, ...
     * @param x the new column value
     * @param scale For java.sql.Types.DECIMAL or java.sql.Types.NUMERIC types
     *  this is the number of digits after the decimal.  For all other
     *  types this value will be ignored.
     * @exception SQLException if a database access error occurs
     */
    public void updateObject(int columnIndex, Object x, int scale)
            throws SQLException {
        connection.log("ResultSet.updateObject");
        if (statement.resultSetConcurrency == ResultSet.CONCUR_READ_ONLY) {
            ScDBError.check_error(257);
            return;
        }
        verify(columnIndex);
        statement.cells.updateElement(statement.i_iCurrentRow - 1, columnIndex - 1, x);
    }

    /**
     * JDBC 2.0
     *
     * Updates a column with an Object value.
     *
     * The <code>updateXXX</code> methods are used to update column values in the
     * current row, or the insert row.  The <code>updateXXX</code> methods do not 
     * update the underlying database; instead the <code>updateRow</code> or <code>insertRow</code>
     * methods are called to update the database.
     *
     * @param columnIndex the first column is 1, the second is 2, ...
     * @param x the new column value
     * @exception SQLException if a database access error occurs
     */
    public void updateObject(int columnIndex, Object x) throws SQLException {
        connection.log("ResultSet.updateObject");
        if (statement.resultSetConcurrency == ResultSet.CONCUR_READ_ONLY) {
            ScDBError.check_error(257);
            return;
        }
        verify(columnIndex);
        statement.cells.updateElement(statement.i_iCurrentRow - 1, columnIndex - 1, x);
    }

    /**
     * JDBC 2.0
     *
     * Updates a column with a null value.
     *
     * The <code>updateXXX</code> methods are used to update column values in the
     * current row, or the insert row.  The <code>updateXXX</code> methods do not 
     * update the underlying database; instead the <code>updateRow</code> or <code>insertRow</code>
     * methods are called to update the database.
     *
     * @param columnName the name of the column
     * @exception SQLException if a database access error occurs
     */
    public void updateNull(String columnName) throws SQLException {
        updateNull(findColumn(columnName));

    }

    /**
     * JDBC 2.0
     *
     * Updates a column with a boolean value.
     *
     * The <code>updateXXX</code> methods are used to update column values in the
     * current row, or the insert row.  The <code>updateXXX</code> methods do not 
     * update the underlying database; instead the <code>updateRow</code> or <code>insertRow</code>
     * methods are called to update the database.
     *
     * @param columnName the name of the column
     * @param x the new column value
     * @exception SQLException if a database access error occurs
     */
    public void updateBoolean(String columnName, boolean x) throws SQLException {
        updateBoolean(findColumn(columnName), x);
    }

    /**
     * JDBC 2.0
     *
     * Updates a column with a byte value.
     *
     * The <code>updateXXX</code> methods are used to update column values in the
     * current row, or the insert row.  The <code>updateXXX</code> methods do not 
     * update the underlying database; instead the <code>updateRow</code> or <code>insertRow</code>
     * methods are called to update the database.
     *
     * @param columnName the name of the column
     * @param x the new column value
     * @exception SQLException if a database access error occurs
     */
    public void updateByte(String columnName, byte x) throws SQLException {
        updateByte(findColumn(columnName), x);
    }

    /**
     * JDBC 2.0
     *
     * Updates a column with a short value.
     *
     * The <code>updateXXX</code> methods are used to update column values in the
     * current row, or the insert row.  The <code>updateXXX</code> methods do not 
     * update the underlying database; instead the <code>updateRow</code> or <code>insertRow</code>
     * methods are called to update the database.
     *
     * @param columnName the name of the column
     * @param x the new column value
     * @exception SQLException if a database access error occurs
     */
    public void updateShort(String columnName, short x) throws SQLException {
        updateShort(findColumn(columnName), x);
    }

    /**
     * JDBC 2.0
     *
     * Updates a column with an integer value.
     *
     * The <code>updateXXX</code> methods are used to update column values in the
     * current row, or the insert row.  The <code>updateXXX</code> methods do not 
     * update the underlying database; instead the <code>updateRow</code> or <code>insertRow</code>
     * methods are called to update the database.
     *
     * @param columnName the name of the column
     * @param x the new column value
     * @exception SQLException if a database access error occurs
     */
    public void updateInt(String columnName, int x) throws SQLException {
        updateInt(findColumn(columnName), x);
    }

    /**
     * JDBC 2.0
     *
     * Updates a column with a long value.
     *
     * The <code>updateXXX</code> methods are used to update column values in the
     * current row, or the insert row.  The <code>updateXXX</code> methods do not 
     * update the underlying database; instead the <code>updateRow</code> or <code>insertRow</code>
     * methods are called to update the database.
     *
     * @param columnName the name of the column
     * @param x the new column value
     * @exception SQLException if a database access error occurs
     */
    public void updateLong(String columnName, long x) throws SQLException {
        updateLong(findColumn(columnName), x);
    }

    /**
     * JDBC 2.0
     *
     * Updates a column with a float value.
     *
     * The <code>updateXXX</code> methods are used to update column values in the
     * current row, or the insert row.  The <code>updateXXX</code> methods do not 
     * update the underlying database; instead the <code>updateRow</code> or <code>insertRow</code>
     * methods are called to update the database.
     *
     * @param columnName the name of the column
     * @param x the new column value
     * @exception SQLException if a database access error occurs
     */
    public void updateFloat(String columnName, float x) throws SQLException {
        updateFloat(findColumn(columnName), x);
    }


    /**
     * JDBC 2.0
     *
     * Updates a column with a double value.
     *
     * The <code>updateXXX</code> methods are used to update column values in the
     * current row, or the insert row.  The <code>updateXXX</code> methods do not 
     * update the underlying database; instead the <code>updateRow</code> or <code>insertRow</code>
     * methods are called to update the database.
     *
     * @param columnName the name of the column
     * @param x the new column value
     * @exception SQLException if a database access error occurs
     */
    public void updateDouble(String columnName, double x) throws SQLException {
        updateDouble(findColumn(columnName), x);
    }

    /**
     * JDBC 2.0
     *
     * Updates a column with a BigDecimal value.
     *
     * The <code>updateXXX</code> methods are used to update column values in the
     * current row, or the insert row.  The <code>updateXXX</code> methods do not 
     * update the underlying database; instead the <code>updateRow</code> or <code>insertRow</code>
     * methods are called to update the database.
     *
     * @param columnName the name of the column
     * @param x the new column value
     * @exception SQLException if a database access error occurs
     */
    public void updateBigDecimal(String columnName, BigDecimal x) throws SQLException {
        updateBigDecimal(findColumn(columnName), x);
    }

    /**
     * JDBC 2.0
     *
     * Updates a column with a String value.
     *
     * The <code>updateXXX</code> methods are used to update column values in the
     * current row, or the insert row.  The <code>updateXXX</code> methods do not 
     * update the underlying database; instead the <code>updateRow</code> or <code>insertRow</code>
     * methods are called to update the database.
     *
     * @param columnName the name of the column
     * @param x the new column value
     * @exception SQLException if a database access error occurs
     */
    public void updateString(String columnName, String x) throws SQLException {
        updateString(findColumn(columnName), x);
    }

    /**
     * JDBC 2.0
     *
     * Updates a column with a byte array value.
     *
     * The <code>updateXXX</code> methods are used to update column values in the
     * current row, or the insert row.  The <code>updateXXX</code> methods do not 
     * update the underlying database; instead the <code>updateRow</code> or <code>insertRow</code>
     * methods are called to update the database.
     *
     * @param columnName the name of the column
     * @param x the new column value
     * @exception SQLException if a database access error occurs
     */
    public void updateBytes(String columnName, byte x[]) throws SQLException {
        updateBytes(findColumn(columnName), x);
    }

    /**
     * JDBC 2.0
     *
     * Updates a column with a Date value.
     *
     * The <code>updateXXX</code> methods are used to update column values in the
     * current row, or the insert row.  The <code>updateXXX</code> methods do not 
     * update the underlying database; instead the <code>updateRow</code> or <code>insertRow</code>
     * methods are called to update the database.
     *
     * @param columnName the name of the column
     * @param x the new column value
     * @exception SQLException if a database access error occurs
     */
    public void updateDate(String columnName, java.sql.Date x) throws SQLException {
        updateDate(findColumn(columnName), x);
    }

    /**
     * JDBC 2.0
     *
     * Updates a column with a Time value.
     *
     * The <code>updateXXX</code> methods are used to update column values in the
     * current row, or the insert row.  The <code>updateXXX</code> methods do not 
     * update the underlying database; instead the <code>updateRow</code> or <code>insertRow</code>
     * methods are called to update the database.
     *
     * @param columnName the name of the column
     * @param x the new column value
     * @exception SQLException if a database access error occurs
     */
    public void updateTime(String columnName, java.sql.Time x) throws SQLException {
        updateTime(findColumn(columnName), x);
    }

    /**
     * JDBC 2.0
     *
     * Updates a column with a Timestamp value.
     *
     * The <code>updateXXX</code> methods are used to update column values in the
     * current row, or the insert row.  The <code>updateXXX</code> methods do not 
     * update the underlying database; instead the <code>updateRow</code> or <code>insertRow</code>
     * methods are called to update the database.
     *
     * @param columnName the name of the column
     * @param x the new column value
     * @exception SQLException if a database access error occurs
     */
    public void updateTimestamp(String columnName, java.sql.Timestamp x)
            throws SQLException {
        updateTimestamp(findColumn(columnName), x);
    }

    /**
     * JDBC 2.0
     *
     * Updates a column with an ascii stream value.
     *
     * The <code>updateXXX</code> methods are used to update column values in the
     * current row, or the insert row.  The <code>updateXXX</code> methods do not 
     * update the underlying database; instead the <code>updateRow</code> or <code>insertRow</code>
     * methods are called to update the database.
     *
     * @param columnName the name of the column
     * @param x the new column value
     * @param length of the stream
     * @exception SQLException if a database access error occurs
     */
    public void updateAsciiStream(String columnName,
                                  java.io.InputStream x,
                                  int length) throws SQLException {
        updateAsciiStream(findColumn(columnName), x, length);
    }

    /**
     * JDBC 2.0
     *
     * Updates a column with a binary stream value.
     *
     * The <code>updateXXX</code> methods are used to update column values in the
     * current row, or the insert row.  The <code>updateXXX</code> methods do not 
     * update the underlying database; instead the <code>updateRow</code> or <code>insertRow</code>
     * methods are called to update the database.
     *
     * @param columnName the name of the column
     * @param x the new column value
     * @param length of the stream
     * @exception SQLException if a database access error occurs
     */
    public void updateBinaryStream(String columnName,
                                   java.io.InputStream x,
                                   int length) throws SQLException {
        updateBinaryStream(findColumn(columnName), x, length);
    }

    /**
     * JDBC 2.0
     *
     * Updates a column with a character stream value.
     *
     * The <code>updateXXX</code> methods are used to update column values in the
     * current row, or the insert row.  The <code>updateXXX</code> methods do not 
     * update the underlying database; instead the <code>updateRow</code> or <code>insertRow</code>
     * methods are called to update the database.
     *
     * @param columnName the name of the column
     * @param x the new column value
     * @param length of the stream
     * @exception SQLException if a database access error occurs
     */
    public void updateCharacterStream(String columnName,
                                      java.io.Reader reader,
                                      int length) throws SQLException {
        updateCharacterStream(findColumn(columnName), reader, length);
    }

    /**
     * JDBC 2.0
     *
     * Updates a column with an Object value.
     *
     * The <code>updateXXX</code> methods are used to update column values in the
     * current row, or the insert row.  The <code>updateXXX</code> methods do not 
     * update the underlying database; instead the <code>updateRow</code> or <code>insertRow</code>
     * methods are called to update the database.
     *
     * @param columnName the name of the column
     * @param x the new column value
     * @param scale For java.sql.Types.DECIMAL or java.sql.Types.NUMERIC types
     *  this is the number of digits after the decimal.  For all other
     *  types this value will be ignored.
     * @exception SQLException if a database access error occurs
     */
    public void updateObject(String columnName, Object x, int scale)
            throws SQLException {
        updateObject(findColumn(columnName), x, scale);
    }

    /**
     * JDBC 2.0
     *
     * Updates a column with an Object value.
     *
     * The <code>updateXXX</code> methods are used to update column values in the
     * current row, or the insert row.  The <code>updateXXX</code> methods do not 
     * update the underlying database; instead the <code>updateRow</code> or <code>insertRow</code>
     * methods are called to update the database.
     *
     * @param columnName the name of the column
     * @param x the new column value
     * @exception SQLException if a database access error occurs
     */
    public void updateObject(String columnName, Object x) throws SQLException {
        updateObject(findColumn(columnName), x);
    }

    /**
     * JDBC 2.0
     *
     * Inserts the contents of the insert row into the result set and
     * the database.  Must be on the insert row when this method is called.
     *
     * @exception SQLException if a database access error occurs,
     * if called when not on the insert row, or if not all of non-nullable columns in
     * the insert row have been given a value
     */
    public void insertRow() throws SQLException {
        connection.log("ResultSet.insertRow");
        if (statement.i_iCurrentRow != (statement.i_iTotalRows + 1))
            throw new SQLException(ScBundle.getMessage(ScResourceKeys.Row_Cursor));
        if (!(i_dBStatement instanceof ScMsqlQueryStatement))
            throw new SQLException(ScBundle.getMessage(ScResourceKeys.Invalid_Statement));

        //get fid names
        Hashtable table = new Hashtable();
        String sTempFid, sTempDi;
        Integer iFileIndex;

        Hashtable[] dataToBeInsert = buildSQL(table);

        String[] sqlStatement;
        if (table.size() > 1) sqlStatement = new String[table.size() + 1];
        else sqlStatement = new String[table.size()];

        long now = System.currentTimeMillis();
        int fileIndex = 0;

        for (fileIndex = 0; fileIndex < table.size(); fileIndex++) {
            String fileName = "";

            Enumeration e = table.keys();
            while (e.hasMoreElements()) {
                sTempFid = (String) e.nextElement();
                iFileIndex = (Integer) table.get(sTempFid);

                if (iFileIndex.intValue() == fileIndex) {
                    fileName = sTempFid;
                    break;
                }
            }

            Enumeration enum1 = dataToBeInsert[fileIndex].keys();
            int k = 0;
            String ss = "";
            String colName = "";
            while (enum1.hasMoreElements()) {
                sTempDi = (String) enum1.nextElement();
                if (sTempDi.indexOf('.') > 0) colName = sTempDi.substring(sTempDi.indexOf('.') + 1, sTempDi.length());
                else colName = sTempDi;
                if (k == 0) {
                    sqlStatement[fileIndex] = "INSERT INTO " + fileName + " (" + colName;
                    ss = " VALUES ('" + (String) dataToBeInsert[fileIndex].get(sTempDi) + "'";
                    k++;
                }//if
                else {
                    sqlStatement[fileIndex] = sqlStatement[fileIndex] + "," + colName;
                    ss = ss + ",'" + (String) dataToBeInsert[fileIndex].get(sTempDi) + "'";
                }//else
            }//while

            sqlStatement[fileIndex] = sqlStatement[fileIndex] + ") " + ss + ")";
            if (table.size() == 1) {
                sqlStatement[fileIndex] = sqlStatement[fileIndex];
                continue;
            }
            if (fileIndex == 0)
                sqlStatement[fileIndex] = "BUFFER NEW " + String.valueOf(now) + " " + sqlStatement[fileIndex];
            else sqlStatement[fileIndex] = "BUFFER ADD " + String.valueOf(now) + " " + sqlStatement[fileIndex];
        }//for

        if (fileIndex > 1) sqlStatement[fileIndex] = "BUFFER COMMIT " + String.valueOf(now);
        Statement s = connection.createStatement();
        for (int i = 0; i < sqlStatement.length; i++) {
            s.executeUpdate(sqlStatement[i]);
        }
        s.close();
        statement.i_iTotalRows = statement.cells.rows();
        statement.copyDesc = new Object[statement.i_iTotalRows][this.getMetaData().getColumnCount()];

        for (int i = 0; i < statement.i_iTotalRows; i++) {
            for (int j = 0; j < statement.i_ahHash.size(); j++) {
                statement.copyDesc[i][j] = statement.cells.elementAt(i, j);
            }
        }
        moveToInsertRow();
    }

    /**
     * Builds the data to be inserted or deleted
     * @param table Hashtable 
     * @return Hashtable[] the built data
     * @throws SQLException
     */
    private Hashtable[] buildSQL(Hashtable table)
            throws SQLException {
        //get fid names
        for (int j = 0; j < statement.description.length; j++) {
            table.put(statement.description[j][0], statement.description[j][0]);
        }

        //create temp hashtable to ket dataToBeInsert(di,value)
        Hashtable[] dataToBeInsert = new Hashtable[table.size()];
        for (int j = 0; j < table.size(); j++) {
            dataToBeInsert[j] = new Hashtable();
        }

        Enumeration enum1 = table.keys();
        int i = 0;
        while (enum1.hasMoreElements())
            table.put(enum1.nextElement(), new Integer(i++));

        String sTempFid, sTempDi, sValue;
        Integer iFileIndex;

        ResultSetMetaData mData = this.getMetaData();

        for (int colIndex = 0; colIndex < statement.i_ahHash.size(); colIndex++) {
            try {
                sValue = (String) statement.cells.elementAt(statement.i_iCurrentRow - 1, colIndex);
            } catch (Exception ee) {
                sValue = "";
            }
            sTempFid = mData.getTableName(colIndex + 1);
            sTempDi = mData.getColumnName(colIndex + 1);
            if (sTempDi.indexOf('.') > 0) sTempDi = sTempDi.substring(sTempDi.indexOf('.') + 1, sTempDi.length());
            iFileIndex = (Integer) table.get(sTempFid);
            dataToBeInsert[iFileIndex.intValue()].put(sTempDi, sValue);
        }
        return dataToBeInsert;
    }

    /**
     * JDBC 2.0
     *
     * Updates the underlying database with the new contents of the
     * current row.  Cannot be called when on the insert row.
     *
     * @exception SQLException if a database access error occurs or
     * if called when on the insert row
     */
    public void updateRow() throws SQLException {
        connection.log("ResultSet.updateRow");
        if (statement.i_iCurrentRow >= statement.i_iTotalRows + 1)
            throw new SQLException(ScBundle.getMessage(ScResourceKeys.Cannot_Called));
        if (!(i_dBStatement instanceof ScMsqlQueryStatement))
            throw new SQLException(ScBundle.getMessage(ScResourceKeys.Invalid_Statement_Update));

        //get fid names
        Hashtable table = new Hashtable();
        String sTempFid, sTempDi;
        Integer iFileIndex;

        Hashtable[] dataToBeInsert = buildSQL(table);

        String[] sqlStatement;
        if (table.size() > 1) sqlStatement = new String[table.size() + 1];
        else sqlStatement = new String[table.size()];

        long now = System.currentTimeMillis();
        int fileIndex = 0;
        Statement s = connection.createStatement();
        DatabaseMetaData mData = connection.getMetaData();
        ResultSet result;

        for (fileIndex = 0; fileIndex < table.size(); fileIndex++) {

            String fileName = "";
            Enumeration e = table.keys();
            while (e.hasMoreElements()) {
                sTempFid = (String) e.nextElement();
                iFileIndex = (Integer) table.get(sTempFid);

                if (iFileIndex.intValue() == fileIndex) {
                    fileName = sTempFid.trim();
                    break;
                }
            }

            Enumeration enum1 = dataToBeInsert[fileIndex].keys();
            int k = 0, indexCol;
            String ss = "";
            String oldCol, newCol, primaryKeys;
            Hashtable whereClasue = new Hashtable();

            while (enum1.hasMoreElements()) {
                sTempDi = (String) enum1.nextElement();
                try {
                    indexCol = findColumn(sTempDi.trim());
                } catch (SQLException e1) {
                    indexCol = findColumn(fileName + "." + sTempDi.trim());
                }

                oldCol = (String) statement.copyDesc[statement.i_iCurrentRow - 1][indexCol - 1];
                newCol = ((String) dataToBeInsert[fileIndex].get(sTempDi)).trim();
                if (oldCol.equals(newCol)) continue;

                if (k == 0) {
                    result = mData.getPrimaryKeys(null, null, fileName);
                    while (result.next()) {
                        primaryKeys = result.getString(4);
                        if (dataToBeInsert[fileIndex].get(primaryKeys) == null) {
                            try {
                                Integer.valueOf(primaryKeys); //constant integer primary key will be ignore
                            } catch (Exception es) {
                                Object[] obj = {fileName, primaryKeys};
                                throw new java.sql.SQLException(ScBundle.getMessage(ScResourceKeys.Cannot_Update, obj));
                            }
                        }
                        try {
                            indexCol = findColumn(primaryKeys);
                        } catch (SQLException e1) {
                            indexCol = findColumn(fileName + "." + primaryKeys);
                        }
                        whereClasue.put(primaryKeys + "='" + (String) statement.copyDesc[statement.i_iCurrentRow - 1][indexCol - 1] + "'", "");
                    }
                    result.close();

                    sqlStatement[fileIndex] = "UPDATE " + fileName + " SET " + sTempDi + " = '" + newCol + "'";
                    ;
                    k++;
                }//if
                else {
                    sqlStatement[fileIndex] = sqlStatement[fileIndex] + "," + sTempDi + " = '" + (String) dataToBeInsert[fileIndex].get(sTempDi) + "'";

                }//else

                try {
                    indexCol = findColumn(sTempDi);
                } catch (SQLException e1) {
                    indexCol = findColumn(fileName + "." + sTempDi);
                }
                whereClasue.put(sTempDi + "='" + (String) statement.copyDesc[statement.i_iCurrentRow - 1][indexCol - 1] + "'", "");
            }//while

            enum1 = whereClasue.keys();
            k = 0;
            while (enum1.hasMoreElements()) {
                if (k == 0) ss = " WHERE " + enum1.nextElement();
                else ss = ss + " AND " + enum1.nextElement();
                k++;
            }
            if (table.size() == 1) {
                sqlStatement[fileIndex] = sqlStatement[fileIndex] + ss;
                continue;
            }
            if ((fileIndex == 0) && (sqlStatement[fileIndex] != null))
                sqlStatement[fileIndex] = "BUFFER NEW " + String.valueOf(now) + " " + sqlStatement[fileIndex] + ss;
            else if (sqlStatement[fileIndex] != null)
                sqlStatement[fileIndex] = "BUFFER ADD " + String.valueOf(now) + " " + sqlStatement[fileIndex] + ss;
        }//for

        for (int k = 0; k < fileIndex; k++) {
            if (sqlStatement[k] != null) break;
            else if ((k == (fileIndex - 1)) && (sqlStatement[k] == null)) return;
        }

        if (fileIndex > 1) sqlStatement[fileIndex] = "BUFFER COMMIT " + String.valueOf(now);
        for (int i = 0; i < sqlStatement.length; i++) {
            if (sqlStatement[i] != null) s.executeUpdate(sqlStatement[i]);
        }

        for (int j = 0; j < statement.i_ahHash.size(); j++) {
            statement.copyDesc[statement.i_iCurrentRow - 1][j] = statement.cells.elementAt(statement.i_iCurrentRow - 1, j);
        }

        s.close();
    }

    /**
     * JDBC 2.0
     *
     * Deletes the current row from the result set and the underlying
     * database.  Cannot be called when on the insert row.
     *
     * @exception SQLException if a database access error occurs or if
     * called when on the insert row.
     */
    public void deleteRow() throws SQLException {
        connection.log("ResultSet.deleteRow");
        if (statement.i_iCurrentRow >= statement.i_iTotalRows + 1)
            throw new SQLException(ScBundle.getMessage(ScResourceKeys.Cannot_Called));
        if (!(i_dBStatement instanceof ScMsqlQueryStatement))
            throw new SQLException(ScBundle.getMessage(ScResourceKeys.Invalid_Statement_Update));

        //get fid names
        Hashtable table = new Hashtable();
        String sTempFid;
        Integer iFileIndex;

        Hashtable[] dataToBeInsert = buildSQL(table);

        String[] sqlStatement;
        if (table.size() == 1) sqlStatement = new String[table.size()];
        else sqlStatement = new String[table.size() + 1];

        long now = System.currentTimeMillis();
        int fileIndex = 0;
        Statement s = connection.createStatement();
        DatabaseMetaData mData = connection.getMetaData();
        ResultSet result;

        for (fileIndex = 0; fileIndex < table.size(); fileIndex++) {
            String fileName = "";
            Enumeration e = table.keys();
            while (e.hasMoreElements()) {
                sTempFid = (String) e.nextElement();
                iFileIndex = (Integer) table.get(sTempFid);

                if (iFileIndex.intValue() == fileIndex) {
                    fileName = sTempFid.trim();
                    break;
                }
            }

            int k = 0, indexCol;
            String ss = "";
            String primaryKeys;
            Hashtable whereClasue = new Hashtable();

            result = mData.getPrimaryKeys(null, null, fileName);
            while (result.next()) {
                primaryKeys = result.getString(6);
                if (dataToBeInsert[fileIndex].get(primaryKeys) == null) {
                    try {
                        Integer.valueOf(primaryKeys);
                    }//try
                    catch (Exception es) {
                        Object[] obj = {fileName, primaryKeys};
                        throw new SQLException(ScBundle.getMessage(ScResourceKeys.Cannot_Delete, obj));
                    }
                }//if

                try {
                    indexCol = findColumn(primaryKeys);
                } catch (SQLException e1) {
                    indexCol = findColumn(fileName + "." + primaryKeys);
                }
                whereClasue.put(primaryKeys + "='" + (String) statement.copyDesc[statement.i_iCurrentRow - 1][indexCol - 1] + "'", "");
            }//while (result.next())
            result.close();

            Enumeration enum1 = whereClasue.keys();
            k = 0;
            while (enum1.hasMoreElements()) {
                if (k == 0) ss = " WHERE " + enum1.nextElement();
                else ss = ss + " AND " + enum1.nextElement();
                k++;
            }
            if (table.size() == 1) {
                sqlStatement[fileIndex] = " DELETE " + fileName + ss;
                break;
            }
            if (fileIndex == 0)
                sqlStatement[fileIndex] = "BUFFER NEW " + String.valueOf(now) + " DELETE " + fileName + ss;
            else sqlStatement[fileIndex] = "BUFFER ADD " + String.valueOf(now) + " DELETE " + fileName + ss;
        }//for

        if (fileIndex > 0) sqlStatement[fileIndex] = "BUFFER COMMIT " + String.valueOf(now);
        for (int i = 0; i < sqlStatement.length; i++) {
            if (sqlStatement[i] != null) s.executeUpdate(sqlStatement[i]);
        }

        statement.cells.removeRow(statement.i_iCurrentRow - 1);
        statement.i_iTotalRows = statement.i_iTotalRows - 1;
        statement.copyDesc = new Object[statement.i_iTotalRows][this.getMetaData().getColumnCount()];
        for (int i = 0; i < statement.i_iTotalRows; i++) {
            for (int j = 0; j < statement.i_ahHash.size(); j++) {
                statement.copyDesc[i][j] = statement.cells.elementAt(i, j);
            }
        }

        s.close();
    }

    /**
     * JDBC 2.0
     *
     * Refreshes the current row with its most recent value in 
     * the database.  Cannot be called when on the insert row.
     *
     * The <code>refreshRow</code> method provides a way for an application to 
     * explicitly tell the JDBC driver to refetch a row(s) from the
     * database.  An application may want to call <code>refreshRow</code> when 
     * caching or prefetching is being done by the JDBC driver to
     * fetch the latest value of a row from the database.  The JDBC driver 
     * may actually refresh multiple rows at once if the fetch size is 
     * greater than one.
     *
     * All values are refetched subject to the transaction isolation 
     * level and cursor sensitivity.  If <code>refreshRow</code> is called after
     * calling <code>updateXXX</code>, but before calling <code>updateRow</code>, then the
     * updates made to the row are lost.  Calling the method <code>refreshRow</code> frequently
     * will likely slow performance.
     *
     * @exception SQLException if a database access error occurs or if
     * called when on the insert row
     */
    public void refreshRow() throws SQLException {
        connection.log("ResultSet.refreshRow");
        if (statement.i_iCurrentRow >= statement.i_iTotalRows + 1)
            throw new SQLException(ScBundle.getMessage(ScResourceKeys.Cannot_Called));
        if (!(i_dBStatement instanceof ScMsqlQueryStatement))
            throw new SQLException(ScBundle.getMessage(ScResourceKeys.Invalid_Statement_Update));

        ((ScMsqlQueryStatement) i_dBStatement).setSqlStatus("0");
        statement.i_iCurrentRow = 0;
        statement.cells.removeAllElements();
        statement.i_iTotalRows = 0;
        statement.gotLastBatch = false;

        try {
            int queryRows = connection.i_dDbAccess.fetch(i_dBStatement);
            statement.add(i_dBStatement);
            closed = false;
            if (((ScMsqlQueryStatement) i_dBStatement).getSqlStatus().equals("01500")) statement.gotLastBatch = true;
        } catch (Exception e) {
            ScDBError.check_error(e);
        }
    }

    /**
     * JDBC 2.0
     *
     * Cancels the updates made to a row.
     * This method may be called after calling an
     * <code>updateXXX</code> method(s) and before calling <code>updateRow</code> to rollback 
     * the updates made to a row.  If no updates have been made or 
     * <code>updateRow</code> has already been called, then this method has no 
     * effect.
     *
     * @exception SQLException if a database access error occurs or if
     * called when on the insert row
     *
     */
    public void cancelRowUpdates() throws SQLException {
        connection.log("ResultSet.cancelRowUpdates");
        if ((statement.cells.rows() == statement.description.length + 1) && (statement.i_iCurrentRow == statement.i_iTotalRows + 1)) {
            statement.cells.removeRow(statement.i_iCurrentRow);
            return;
        } else {
            int rowCount = statement.i_iCurrentRow - 1;
            for (int i = 0; i < statement.i_ahHash.size(); i++) {
                statement.cells.updateElement(rowCount, i, statement.copyDesc[rowCount][i]);
            }
        }
    }

    /**
     * JDBC 2.0
     *
     * Moves the cursor to the insert row.  The current cursor position is 
     * remembered while the cursor is positioned on the insert row.
     *
     * The insert row is a special row associated with an updatable
     * result set.  It is essentially a buffer where a new row may
     * be constructed by calling the <code>updateXXX</code> methods prior to 
     * inserting the row into the result set.  
     *
     * Only the <code>updateXXX</code>, <code>getXXX</code>,
     * and <code>insertRow</code> methods may be
     * called when the cursor is on the insert row.  All of the columns in 
     * a result set must be given a value each time this method is
     * called before calling <code>insertRow</code>.  
     * The method <code>updateXXX</code> must be called before a
     * <code>getXXX</code> method can be called on a column value.
     *
     * @exception SQLException if a database access error occurs
     * or the result set is not updatable
     */
    public void moveToInsertRow() throws SQLException {
        connection.log("ResultSet.moveToInsertRow");
        oldCurrentRow = statement.i_iCurrentRow;
        afterLast();
    }

    /**
     * JDBC 2.0
     *
     * Moves the cursor to the remembered cursor position, usually the
     * current row.  This method has no effect if the cursor is not on the insert 
     * row. 
     *
     * @exception SQLException if a database access error occurs
     * or the result set is not updatable
     */
    public void moveToCurrentRow() throws SQLException {
        connection.log("ResultSet.moveToCurrentRow");
        if (statement.i_iTotalRows + 1 == statement.i_iCurrentRow) {
            statement.i_iCurrentRow = oldCurrentRow;
        }
    }

    /**
     * JDBC 2.0
     *
     * Returns the Statement that produced this <code>ResultSet</code> object.
     * If the result set was generated some other way, such as by a
     * <code>DatabaseMetaData</code> method, this method returns <code>null</code>.
     *
     * @return the Statment that produced the result set or
     * null if the result set was produced some other way
     * @exception SQLException if a database access error occurs
     */
    public Statement getStatement() throws SQLException {
        connection.log("ResultSet.getStatement");
        return statement;
    }

    /**
     * JDBC 2.0
     *
     * Returns the value of a column in the current row as a Java object.  
     * This method uses the given <code>Map</code> object
     * for the custom mapping of the
     * SQL structured or distinct type that is being retrieved.
     *
     * @param i the first column is 1, the second is 2, ...
     * @param map the mapping from SQL type names to Java classes
     * @return an object representing the SQL value
     */
    public Object getObject(int i, java.util.Map map) throws SQLException {
        connection.log("ResultSet.getObject");
        currentColIndex = i;

        Object obj = getObject(i);
        if (obj == null)
            return null;

        if (obj instanceof Struct) {
            Struct struct = (Struct) obj;
            Class class1 = (Class) map.get(struct.getSQLTypeName());
            if (class1 != null) {
                SQLData sqldata = null;
                try {
                    sqldata = (SQLData) class1.newInstance();
                } catch (InstantiationException instantiationexception) {
                    Object[] objs = {instantiationexception.getMessage()};
                    throw new SQLException(ScBundle.getMessage(ScResourceKeys.Unable_to_instantiate, objs));
                } catch (IllegalAccessException illegalaccessexception) {
                    Object[] objs = {illegalaccessexception.getMessage()};
                    throw new SQLException(ScBundle.getMessage(ScResourceKeys.Unable_to_instantiate, objs));
                }
                Object aobj[] = struct.getAttributes(map);
                ScSQLInputImpl sqlinputimpl = new ScSQLInputImpl(aobj, map);
                sqldata.readSQL(sqlinputimpl, struct.getSQLTypeName());
                return sqldata;
            }
        }
        return obj;
    }

    /**
     * JDBC 2.0
     *
     * Gets a REF(&lt;structured-type&gt;) column value from the current row.
     *
     * @param i the first column is 1, the second is 2, ...
     * @return a <code>Ref</code> object representing an SQL REF value
     */
    public java.sql.Ref getRef(int i) throws SQLException {
        currentColIndex = i;
        return null;
    }

    /**
     * JDBC 2.0
     *
     * Gets a BLOB value in the current row of this <code>ResultSet</code> object.
     *
     * @param i the first column is 1, the second is 2, ...
     * @return a <code>Blob</code> object representing the SQL BLOB value in
     *         the specified column
     */
    public Blob getBlob(int columnIndex) throws SQLException {
        connection.log("ResultSet.getBlob");
        currentColIndex = columnIndex;
        if (this.wasNull()) return null;
        if (statement.i_iTotalRows == 0) return null;

        String asTemp = (String) statement.cells.elementAt(statement.i_iCurrentRow - 1, columnIndex - 1);
        try {
            //below one line will be removed after profile bug was for bulk message with escape characters updating
            String s = (String) ScSerialUtils.ScGetObjectFromString(asTemp);
            byte[] b = ScUtils.stringToByte(s);
            ScSerialBlob blob = new ScSerialBlob(b);
            return blob;
        } catch (Exception e) {
            ScDBError.check_error(e);
        }
        return null;
    }

    /**
     * JDBC 2.0
     *
     * Gets a CLOB value in the current row of this <code>ResultSet</code> object.
     *
     * @param i the first column is 1, the second is 2, ...
     * @return a <code>Clob</code> object representing the SQL CLOB value in
     *         the specified column
     */
    public Clob getClob(int columnIndex) throws SQLException {
        connection.log("ResultSet.getClob");
        currentColIndex = columnIndex;
        if (this.wasNull()) return null;
        if (statement.i_iTotalRows == 0) return null;

        String ss = (String) statement.cells.elementAt(statement.i_iCurrentRow - 1, columnIndex - 1);
        try {
            //unicode supporting
            String fileEncoding = (String) connection.info.get("ENCODING");
            if (fileEncoding == null)
                ss = new String(ScUtils.stringToByte(ss), "8859_1");
            else if (fileEncoding.equalsIgnoreCase("UTF16") || fileEncoding.equalsIgnoreCase("UTF-16")) {
                ss = new String(ScUtils.stringToByte(ss), "UTF8");
                byte[] barray = ss.getBytes("UTF16");
                ss = new String(barray, "UTF16");
            } else ss = new String(ScUtils.stringToByte(ss), fileEncoding);

            //below one line will be removed after profile bug was for bulk message with escape characters updating
            ss = (String) ScSerialUtils.ScGetObjectFromString(ss);
            char[] chars = ss.toCharArray();
            ScSerialClob clob = new ScSerialClob(chars);
            return clob;

        } catch (Exception e) {
        }

        return null;
    }

    /**
     * JDBC 2.0
     *
     * Gets an SQL ARRAY value from the current row of this <code>ResultSet</code> object.
     *
     * @param i the first column is 1, the second is 2, ...
     * @return an <code>Array</code> object representing the SQL ARRAY value in
     *         the specified column
     */
    public Array getArray(int i) throws SQLException {
        connection.log("ResultSet.getArray");
        return null;
    }

    /**
     * JDBC 2.0
     *
     * Returns the value in the specified column as a Java object.  
     * This method uses the specified <code>Map</code> object for
     * custom mapping if appropriate.
     *
     * @param colName the name of the column from which to retrieve the value
     * @param map the mapping from SQL type names to Java classes
     * @return an object representing the SQL value in the specified column
     */

    public Object getObject(String colName, java.util.Map map) throws SQLException {
        return null;
    }

    /**
     * JDBC 2.0
     *
     * Gets a REF(&lt;structured-type&gt;) column value from the current row.
     *
     * @param colName the column name
     * @return a <code>Ref</code> object representing the SQL REF value in
     *         the specified column
     */
    public java.sql.Ref getRef(String colName) throws SQLException {
        return null;
    }

    /**
     * JDBC 2.0
     *
     * Gets a BLOB value in the current row of this <code>ResultSet</code> object.
     *
     * @param colName the name of the column from which to retrieve the value
     * @return a <code>Blob</code> object representing the SQL BLOB value in
     *         the specified column
     */
    public Blob getBlob(String colName) throws SQLException {
        return getBlob(findColumn(colName));
    }

    /**
     * JDBC 2.0
     *
     * Gets a CLOB value in the current row of this <code>ResultSet</code> object.
     *
     * @param colName the name of the column from which to retrieve the value
     * @return a <code>Clob</code> object representing the SQL CLOB value in
     *         the specified column
     */
    public Clob getClob(String colName) throws SQLException {
        return getClob(findColumn(colName));
    }

    /**
     * JDBC 2.0
     *
     * Gets an SQL ARRAY value in the current row of this <code>ResultSet</code> object.
     *
     * @param colName the name of the column from which to retrieve the value
     * @return an <code>Array</code> object representing the SQL ARRAY value in
     *         the specified column
     */
    public Array getArray(String colName) throws SQLException {
        connection.log("ResultSet.getArray");
        return null;
    }

    /**
     * JDBC 2.0
     *
     * Gets the value of a column in the current row as a java.sql.Date 
     * object. This method uses the given calendar to construct an appropriate millisecond
     * value for the Date if the underlying database does not store
     * timezone information.
     *
     * @param columnIndex the first column is 1, the second is 2, ...
     * @param cal the calendar to use in constructing the date
     * @return the column value; if the value is SQL NULL, the result is null
     * @exception SQLException if a database access error occurs
     */
    public java.sql.Date getDate(int columnIndex, Calendar calendar) throws SQLException {
        Object obj = convertTemporal(getObject(columnIndex), getColumnType(columnIndex), 91);

        if (obj == null) {
            return null;
        }
        if (calendar == null) {
            return getDate(columnIndex);
        }
        java.util.Date result = getDate(columnIndex);
        if (result != null) {
            java.util.Calendar targetCalendar = java.util.Calendar.getInstance(calendar.getTimeZone());
            targetCalendar.clear();
            targetCalendar.setTime(result);
            java.util.Calendar defaultCalendar = java.util.Calendar.getInstance();
            defaultCalendar.clear();
            defaultCalendar.setTime(result);
            long timeZoneOffset =
                    targetCalendar.get(java.util.Calendar.ZONE_OFFSET) -
                            defaultCalendar.get(java.util.Calendar.ZONE_OFFSET) +
                            targetCalendar.get(java.util.Calendar.DST_OFFSET) -
                            defaultCalendar.get(java.util.Calendar.DST_OFFSET);
            result.setTime(result.getTime() - timeZoneOffset);
        }
        return new java.sql.Date(result.getTime());
    }

    /**
     * Gets the value of a column in the current row as a java.sql.Date 
     * object. This method uses the given calendar to construct an appropriate millisecond
     * value for the Date, if the underlying database does not store
     * timezone information.
     *
     * @param columnName the SQL name of the column from which to retrieve the value
     * @param cal the calendar to use in constructing the date
     * @return the column value; if the value is SQL NULL, the result is null
     * @exception SQLException if a database access error occurs
     */
    public java.sql.Date getDate(String columnName, Calendar cal) throws SQLException {
        return getDate(findColumn(columnName), cal);
    }

    /**
     * Gets the value of a column in the current row as a java.sql.Time 
     * object. This method uses the given calendar to construct an appropriate millisecond
     * value for the Time if the underlying database does not store
     * timezone information.
     *
     * @param columnIndex the first column is 1, the second is 2, ...
     * @param cal the calendar to use in constructing the time
     * @return the column value; if the value is SQL NULL, the result is null
     * @exception SQLException if a database access error occurs
     */
    public java.sql.Time getTime(int columnIndex, Calendar calendar) throws SQLException {
        Time result = getTime(columnIndex);
        if (result != null) {
            java.util.Calendar targetCalendar = java.util.Calendar.getInstance(calendar.getTimeZone());
            targetCalendar.clear();
            targetCalendar.setTime(result);
            java.util.Calendar defaultCalendar = java.util.Calendar.getInstance();
            defaultCalendar.clear();
            defaultCalendar.setTime(result);
            long timeZoneOffset =
                    targetCalendar.get(java.util.Calendar.ZONE_OFFSET) -
                            defaultCalendar.get(java.util.Calendar.ZONE_OFFSET) +
                            targetCalendar.get(java.util.Calendar.DST_OFFSET) -
                            defaultCalendar.get(java.util.Calendar.DST_OFFSET);
            result.setTime(result.getTime() - timeZoneOffset);
        }
        return result;
    }

    /**
     * Gets the value of a column in the current row as a java.sql.Time 
     * object. This method uses the given calendar to construct an appropriate millisecond
     * value for the Time if the underlying database does not store
     * timezone information.
     *
     * @param columnName the SQL name of the column
     * @param cal the calendar to use in constructing the time
     * @return the column value; if the value is SQL NULL, the result is null
     * @exception SQLException if a database access error occurs
     */
    public java.sql.Time getTime(String columnName, Calendar cal) throws SQLException {

        return getTime(findColumn(columnName), cal);
    }

    /**
     * Gets the value of a column in the current row as a java.sql.Timestamp 
     * object. This method uses the given calendar to construct an appropriate millisecond
     * value for the Timestamp if the underlying database does not store
     * timezone information.
     *
     * @param columnIndex the first column is 1, the second is 2, ...
     * @param cal the calendar to use in constructing the timestamp
     * @return the column value; if the value is SQL NULL, the result is null
     * @exception SQLException if a database access error occurs
     */
    public java.sql.Timestamp getTimestamp(int columnIndex, Calendar calendar)
            throws SQLException {
        Timestamp obj = getTimestamp(columnIndex);
        if (obj != null) {
            java.util.Calendar targetCalendar = java.util.Calendar.getInstance(calendar.getTimeZone());
            targetCalendar.clear();
            targetCalendar.setTime(obj);
            java.util.Calendar defaultCalendar = java.util.Calendar.getInstance();
            defaultCalendar.clear();
            defaultCalendar.setTime(obj);
            long timeZoneOffset =
                    targetCalendar.get(java.util.Calendar.ZONE_OFFSET) -
                            defaultCalendar.get(java.util.Calendar.ZONE_OFFSET) +
                            targetCalendar.get(java.util.Calendar.DST_OFFSET) -
                            defaultCalendar.get(java.util.Calendar.DST_OFFSET);
            obj.setTime(obj.getTime() - timeZoneOffset);
        }
        return obj;
    }

    /**
     * Gets the value of a column in the current row as a java.sql.Timestamp 
     * object. This method uses the given calendar to construct an appropriate millisecond
     * value for the Timestamp if the underlying database does not store
     * timezone information.
     *
     * @param columnName the SQL name of the column
     * @param cal the calendar to use in constructing the timestamp
     * @return the column value; if the value is SQL NULL, the result is null
     * @exception SQLException if a database access error occurs
     */
    public java.sql.Timestamp getTimestamp(String columnName, Calendar cal)
            throws SQLException {
        return getTimestamp(findColumn(columnName), cal);
    }

    /**
     * Close the cursor 
     * @exception SQLException if a database access error occurs
     */
    public void internalClose()
            throws SQLException {
        if (closed)
            return;
        closed = true;

        if (i_dBStatement instanceof ScMsqlQueryStatement) {
            try {
                statement.connection.i_dDbAccess.closeQuery(i_dBStatement);
            } catch (Exception e) {
                ScDBError.check_error(e);
            }
        }

        //statement.end_of_result_set();
        if (closeStatementOnClose) {
            statement.close();
        }
    }

    /**
     * Checks the validity of the parameter index.
     * @param parameterIndex the parameter index to be verified
     * @exception SQLException if a database access error occurs
     */
    protected void verify(int parameterIndex)
            throws SQLException {
        if (statement.i_iCurrentRow == 0) {
            throw new SQLException(ScBundle.getMessage(ScResourceKeys.Current_row));
        }
        // The paramCount was set when the statement was prepared
        if ((parameterIndex <= 0) ||
                (parameterIndex > statement.i_ahHash.size())) {
            Object[] obj = {Integer.valueOf(String.valueOf(parameterIndex))};
            throw new SQLException(ScBundle.getMessage(ScResourceKeys.Invalid_parameter_number, obj));
        }
    }

    /**
     * According to the precision of the numeral,specific integer type or generic numeric type is returned.
     * @param sPrecision
     * @return integer
     */
    private int getNumericType(String sPrecision) {
        if (sPrecision != null) {
            if (sPrecision.length() < 1) {
                // Number is not decimal
                return Types.BIGINT;
            } else {
                // Number is decimal
                return Types.NUMERIC;
            }
        }
        return Types.NUMERIC;
    }

    /**
     * Gets the data type of the column index.
     * @param column column index for which the data type is required
     * @exception SQLException if a database access error occurs
     */
    private int getColumnType(int column) throws SQLException {
        int type = 0;
        int index = column - 1;

        String sType = statement.description[index][4];
        String sLen = statement.description[index][2];
        String sDec = statement.description[index][8];
        String sTotal = statement.description[index][6];
        int iLen = Integer.parseInt(sLen);

        if (sType.compareTo("L") == 0) type = -7; //BIT
        else if (sType.compareTo("B") == 0) type = Types.BLOB;  //BLOB
        else if (sType.compareTo("D") == 0) type = 91;  //DATE
        else if (sType.compareTo("C") == 0) type = 92;  //TIME
            //else if (sType.compareTo("$")==0) type =99;    //CURRENCY
            //99 is not a invalid sql data type and it is not accepted by SUN studio creator
        else if (sType.compareTo("$") == 0) type = 3;    //CURRENCY
        else if ((sType.compareTo("T") == 0) || (sType.compareTo("U") == 0) || (sType.compareTo("F") == 0))
            type = 12;  //VARCHAR
        else if (sType.compareTo("M") == 0) type = java.sql.Types.LONGVARCHAR;
            //else if (sType.compareTo("M")==0) type = java.sql.Types.CLOB;
        else if (sType.compareTo("N") == 0) {
            type = getNumericType(sDec);
        } else try {
            type = Integer.parseInt(sType);
        } catch (Exception e) {
            type = 1111;
        }
        return type;
    }

    /**
     * Formats the input string into numeric representation
     * @param a_sTemp : The input string to be formatted
     * @param colIndex : The column index
     * @return the formatted String
     * @throws SQLException
     */
    private String numberConvert(String a_sTemp, int colIndex)
            throws SQLException {
        if (a_sTemp.startsWith(".")) a_sTemp = "0" + a_sTemp;
        int colType = getColumnType(colIndex);

        if ((a_sTemp.length() < 1) && ((colType == 99) || (colType == 3))) return "0.00";
        else if (a_sTemp.length() < 1) return "";
        //scale
        String sDec = statement.description[colIndex - 1][8];
        if (sDec.length() < 1) sDec = "0";

        int iDec = Integer.parseInt(sDec);

        if ((iDec == 0) && ((colType != 99) || (colType != 3))) return a_sTemp;

        int i;
        i = a_sTemp.indexOf(".");
        if (i < 0) i = a_sTemp.length() - 1;
        else i = i - 1;

        int iIndex = a_sTemp.indexOf(".");
        if (iIndex < 0) {
            a_sTemp = a_sTemp + ".";
            for (i = 0; i < iDec; i++) {
                a_sTemp = a_sTemp + "0";
            }
            return a_sTemp;
        }

        sDec = a_sTemp.trim().substring(iIndex + 1, a_sTemp.length());

        if (sDec.length() == iDec) return a_sTemp;
        if ((sDec.length() > 2) && ((colType == 99) || (colType == 3))) sDec = sDec.substring(0, 2);
        int j = iDec - sDec.length();
        for (i = 0; i < j; i++) {
            sDec = sDec + "0";
        }
        return a_sTemp.substring(0, a_sTemp.indexOf(".") + 1) + sDec;
    }

    /**
     * Converts a Date/Time/TimeStamp Object into one of the target Date/Time/Timestamp type
     * @param obj : The column index
     * @param i : The current type
     * @param j : The target Type
     * @return the converted Date/Time/Timestamp object
     * @throws SQLException if the conversion cannot be done
     */
    /*
     * For Timestamp i.e. Type (j) =93, if its varchar i.e. i=12,
     * Timestamp.valueOf(obj.toString()) is to be used.
     */
    private Object convertTemporal(Object obj, int i, int j)
            throws SQLException {
        if (i == j)
            return obj;
        if (isNumeric(j) || !isString(j) && !isTemporal(j))
            throw new SQLException(ScBundle.getMessage(ScResourceKeys.Data_type_mismatch));
        try {
            switch (j) {
                case 91: // '['
                    if (i == 93)
                        return new Date(((Timestamp) obj).getTime());
                    else
                        throw new SQLException(ScBundle.getMessage(ScResourceKeys.Data_type_mismatch));

                case 93: // ']'
                    if (i == 92)
                        return new Timestamp(((Time) obj).getTime());
                    else if (i == 12)
                        return Timestamp.valueOf(obj.toString());//Added Dip :06/06/2006 : End
                    else
                        return new Timestamp(((Date) obj).getTime());

                case 92: // '\\'
                    if (i == 93)
                        return new Time(((Timestamp) obj).getTime());
                    else
                        throw new SQLException(ScBundle.getMessage(ScResourceKeys.Data_type_mismatch));

                case -1:
                case 1: // '\001'
                case 12: // '\f'
                    return new String(obj.toString());
            }
            throw new SQLException(ScBundle.getMessage(ScResourceKeys.Data_type_mismatch));
        } catch (NumberFormatException _ex) {
            throw new SQLException(ScBundle.getMessage(ScResourceKeys.Data_type_mismatch));
        }
    }

    /**
     * Converts the input Object to desired representation
     * @param obj : The input Objkect to be converted
     * @param j   : The desired Object Type 
     * @return    : The converted Object
     * @throws SQLException if conversion cannot be possible or the target type is undefined 
     */
    private Object convertNumeric(Object obj, int i, int j) throws SQLException {
        if (i == j)
            return obj;
        if (!isNumeric(j) && !isString(j)) {
            Object[] objs = {Integer.valueOf(String.valueOf(j))};
            throw new SQLException(ScBundle.getMessage(ScResourceKeys.Datatype_Mismatch_1, objs));
        }
        try {
            switch (j) {
                case -7:
                    Integer integer = new Integer(obj.toString().trim());
                    return integer.equals(new Integer(0)) ? new Boolean(false) : new Boolean(true);

                case -6:
                    return new Byte(obj.toString().trim());

                case 5: // '\005'
                    return new Short(obj.toString().trim());

                case 4: // '\004'
                    return new Integer(obj.toString().trim());

                case -5:
                    return new Long(obj.toString().trim());

                case 2: // '\002'
                case 3: // '\003'
                    return new BigDecimal(obj.toString().trim());

                case 6: // '\006'
                case 7: // '\007'
                    return new Float(obj.toString().trim());

                case 8: // '\b'
                    return new Double(obj.toString().trim());

                case -1:
                case 1: // '\001'
                case 12: // '\f'
                    return new String(obj.toString());

                case -4:
                case -3:
                case -2:
                case 0: // '\0'
                case 9: // '\t'
                case 10: // '\n'
                case 11: // '\013'
                default:
                    Object[] objs = {Integer.valueOf(String.valueOf(j))};
                    throw new SQLException(ScBundle.getMessage(ScResourceKeys.Datatype_Mismatch_2, objs));
            }
        } catch (NumberFormatException _ex) {
            Object[] objs = {Integer.valueOf(String.valueOf(j))};
            throw new SQLException(ScBundle.getMessage(ScResourceKeys.Datatype_Mismatch_3, objs));
        }
    }

    /**
     * Checks whether a value is valid SQL Numeric Type  
     * @param i : Value to be checked
     * @return boolean true or false 
     */
    private boolean isNumeric(int i) {
        switch (i) {
            case -7:
            case -6:
            case -5:
            case 2: // '\002'
            case 3: // '\003'
            case 4: // '\004'
            case 5: // '\005'
            case 6: // '\006'
            case 7: // '\007'
            case 8: // '\b'
                return true;

            case -4:
            case -3:
            case -2:
            case -1:
            case 0: // '\0'
            case 1: // '\001'
            default:
                return false;
        }
    }

    /**
     * Checks whether a value is valid SQL String/Char Type  
     * @param i : Value to be checked
     * @return boolean true or false 
     */
    private boolean isString(int i) {
        switch (i) {
            case -1:
            case 1: // '\001'
            case 12: // '\f'
                return true;
        }
        return false;
    }

    /**
     * Checks whether a value is valid DATE/TIME/TIMESTAMP Type  
     * @param i : Value to be checked
     * @return boolean true or false 
     */
    private boolean isTemporal(int i) {
        switch (i) {
            case 91: // '['
            case 92: // '\\'
            case 93: // ']'
                return true;
        }
        return false;
    }

    /**
     * Checks whether a value is valid Binary Type  
     * @param i : Value to be checked
     * @return boolean true or false 
     */
    private boolean isBinary(int i) {
        switch (i) {
            case -4:
            case -3:
            case -2:
                return true;
        }
        return false;
    }

    /**
     * Formats a Date according to the format specified in connection.  
     * @param sDate Date to be formatted
     * @return String formatted date String 
     */
    private String getFormatDate(String sDate) {
        try {
            String datepattern = (String) connection.info.get("dateFormat");

            if (datepattern == null || datepattern.length() < 1) return sDate;
            else if (connection.sm != null) return connection.sm.getDisplayDateFromJdbcDate(sDate);
            else return sDate;
        } catch (Exception e) {
            return sDate;
        }
    }

    /**
     * Formats a Time according to the format specified in connection.
     * @param sDate Time to be formatted
     * @return String formatted time String
     */
    private String getFormatTime(String sDate) {
        try {
            String timepattern = (String) connection.info.get("timeFormat");

            if (timepattern == null || timepattern.length() < 1 || connection.sm == null) return sDate;
            else return connection.sm.getDisplayTimeFromJdbcTime(sDate);
        } catch (Exception e) {
            return sDate;
        }
    }

    /**
     * Formats a Number according to the format specified in connection.
     * @param columnIndex The parameter/column index
     * @param iType The Type of the target
     * @param sNumber Number to be formatted
     * @return String formatted number in String format
     */
    private String getFormatNumber(int columnIndex, int iType, String sNumber) {
        try {
            String numberpattern = (String) connection.info.get("numberFormat");

            if (numberpattern == null || numberpattern.length() < 1 || connection.sm == null) return sNumber;

            switch (iType) {
                case 3:     //Decimal
                case 99:    //Currency
                    try {
                        double dDouble = getDouble(columnIndex);
                        String sTemp = connection.nm.getFormattedCurrency(dDouble);
                        if (sTemp == null) sTemp = "";
                        return sTemp;
                    } catch (Exception e) {
                        return "";
                    }

                case 2:     //Numeric
                case 6:     //Float
                case 8:     //Double
                    try {
                        double dDouble = getDouble(columnIndex);
                        String sTemp = connection.nm.getFormattedNumber(dDouble);
                        if (sTemp == null) sTemp = "";
                        return sTemp;
                    } catch (Exception e) {
                        return "";
                    }
                default:
                    return sNumber;
            }
        } catch (Exception e) {
            return sNumber;
        }
    }

    /**
     * Get a TimeStamp from String after formating according to the format
     * set in Connection Object
     *
     * @param sTimeStamp The Timestamp to be formatted
     * @return Timestamp The TimeStamp value
     */
    private Timestamp getFormatTimeStamp(String sTimeStamp) throws Exception  // To be Added From here
    {
        try {
            String timestampPattern = (String) connection.info.get("timestampFormat");
            if (connection.sm != null) return
                    connection.sm.getDisplayTimeStampFromJdbcTimestamp(sTimeStamp, timestampPattern);
            else return Timestamp.valueOf(sTimeStamp);
        } catch (Exception e) {
            return Timestamp.valueOf(sTimeStamp);
        }
    }


// --------------------------JDBC 3.0-----------------------------

    /* (non-Javadoc)
     * @see java.sql.ResultSet#getURL(int)
     */
    public URL getURL(int columnIndex) throws SQLException {
        ScDBError.check_error(-52, "java.sql.ResultSet#getURL(int)");
        return null;
    }

    /* (non-Javadoc)
     * @see java.sql.ResultSet#getURL(java.lang.String)
     */
    public URL getURL(String columnName) throws SQLException {
        ScDBError.check_error(-52, "java.sql.ResultSet#getURL(java.lang.String)");
        return null;
    }

    /* (non-Javadoc)
     * @see java.sql.ResultSet#updateRef(int, java.sql.Ref)
     */
    public void updateRef(int columnIndex, java.sql.Ref x) throws SQLException {
        ScDBError.check_error(-52, "java.sql.ResultSet#updateRef(int, java.sql.Ref)");

    }

    /* (non-Javadoc)
     * @see java.sql.ResultSet#updateRef(java.lang.String, java.sql.Ref)
     */
    public void updateRef(String columnName, java.sql.Ref x) throws SQLException {
        ScDBError.check_error(-52, "java.sql.ResultSet#updateRef(java.lang.String, java.sql.Ref)");

    }

    /* (non-Javadoc)
     * @see java.sql.ResultSet#updateBlob(int, java.sql.Blob)
     */
    public void updateBlob(int columnIndex, Blob x) throws SQLException {
        ScDBError.check_error(-52, "java.sql.ResultSet#updateBlob(int, java.sql.Blob)");

    }

    /* (non-Javadoc)
     * @see java.sql.ResultSet#updateBlob(java.lang.String, java.sql.Blob)
     */
    public void updateBlob(String columnName, Blob x) throws SQLException {
        ScDBError.check_error(-52, "java.sql.ResultSet#updateBlob(java.lang.String, java.sql.Blob)");

    }

    /* (non-Javadoc)
     * @see java.sql.ResultSet#updateClob(int, java.sql.Clob)
     */
    public void updateClob(int columnIndex, Clob x) throws SQLException {
        ScDBError.check_error(-52, "java.sql.ResultSet#updateClob(int, java.sql.Clob)");

    }

    /* (non-Javadoc)
     * @see java.sql.ResultSet#updateClob(java.lang.String, java.sql.Clob)
     */
    public void updateClob(String columnName, Clob x) throws SQLException {
        ScDBError.check_error(-52, "java.sql.ResultSet#updateClob(java.lang.String, java.sql.Clob)");

    }

    /* (non-Javadoc)
     * @see java.sql.ResultSet#updateArray(int, java.sql.Array)
     */
    public void updateArray(int columnIndex, Array x) throws SQLException {
        ScDBError.check_error(-52, "java.sql.ResultSet#updateArray(int, java.sql.Array)");

    }

    /* (non-Javadoc)
     * @see java.sql.ResultSet#updateArray(java.lang.String, java.sql.Array)
     */
    public void updateArray(String columnName, Array x) throws SQLException {
        ScDBError.check_error(-52, "java.sql.ResultSet#updateArray(java.lang.String, java.sql.Array)");

    }

    public ScConnection getScConnection() {
        return connection;
    }

    @Override
    public <T> T getObject(int columnIndex, Class<T> type) {
        return null;
    }

    @Override
    public <T> T getObject(String columnLabel, Class<T> type) {
        return null;
    }

    @Override
    public void updateNClob(int columnIndex, NClob nClob) {

    }

    @Override
    public void updateNClob(int columnIndex, Reader reader) {

    }

    @Override
    public void updateNClob(String columnLabel, NClob nClob) {

    }

    @Override
    public void updateNClob(String columnLabel, Reader reader) {

    }

    @Override
    public void updateNClob(int columnIndex, Reader reader, long length) {

    }

    @Override
    public void updateNClob(String columnLabel, Reader reader, long length) {

    }

    @Override
    public void updateClob(int columnIndex, Reader reader) {

    }

    @Override
    public void updateClob(String columnLabel, Reader reader) {

    }

    @Override
    public void updateClob(int columnIndex, Reader reader, long length) {

    }

    @Override
    public void updateClob(String columnLabel, Reader reader, long length) {

    }

    @Override
    public void updateBlob(int columnIndex, InputStream inputStream) {

    }

    @Override
    public void updateBlob(String columnLabel, InputStream inputStream) {

    }

    @Override
    public void updateBlob(int columnIndex, InputStream inputStream, long length) {

    }

    @Override
    public void updateBlob(String columnLabel, InputStream inputStream, long length) {

    }

    @Override
    public void updateCharacterStream(int columnIndex, Reader x) {

    }

    @Override
    public void updateCharacterStream(String columnLabel, Reader reader) {

    }

    @Override
    public void updateCharacterStream(int columnIndex, Reader x, long length) {

    }

    @Override
    public void updateCharacterStream(String columnLabel, Reader reader, long length) {

    }

    @Override
    public void updateBinaryStream(int columnIndex, InputStream x) {

    }

    @Override
    public void updateBinaryStream(String columnLabel, InputStream x) {

    }

    @Override
    public void updateBinaryStream(int columnIndex, InputStream x, long length) {

    }

    @Override
    public void updateBinaryStream(String columnLabel, InputStream x, long length) {

    }

    @Override
    public void updateAsciiStream(int columnIndex, InputStream x) {

    }

    @Override
    public void updateAsciiStream(String columnLabel, InputStream x) {

    }

    @Override
    public void updateAsciiStream(int columnIndex, InputStream x, long length) {

    }

    @Override
    public void updateAsciiStream(String columnLabel, InputStream x, long length) {

    }

    @Override
    public void updateNCharacterStream(int columnIndex, Reader x) {

    }

    @Override
    public void updateNCharacterStream(String columnLabel, Reader reader) {

    }

    @Override
    public void updateNCharacterStream(int columnIndex, Reader x, long length) {

    }

    @Override
    public void updateNCharacterStream(String columnLabel, Reader reader, long length) {

    }

    @Override
    public Reader getNCharacterStream(int columnIndex) {
        return null;
    }

    @Override
    public Reader getNCharacterStream(String columnLabel) {
        return null;
    }

    @Override
    public String getNString(int columnIndex) {
        return null;
    }

    @Override
    public String getNString(String columnLabel) {
        return null;
    }

    @Override
    public void updateSQLXML(int columnIndex, SQLXML xmlObject) {

    }

    @Override
    public void updateSQLXML(String columnLabel, SQLXML xmlObject) {

    }

    @Override
    public SQLXML getSQLXML(int columnIndex) {
        return null;
    }

    @Override
    public SQLXML getSQLXML(String columnLabel) {
        return null;
    }

    @Override
    public NClob getNClob(int columnIndex) {
        return null;
    }

    @Override
    public NClob getNClob(String columnLabel) {
        return null;
    }

    @Override
    public void updateNString(int columnIndex, String nString) {

    }

    @Override
    public void updateNString(String columnLabel, String nString) {

    }

    @Override
    public boolean isClosed() {
        return closed;
    }

    @Override
    public int getHoldability() {
        return 0;
    }

    @Override
    public void updateRowId(int columnIndex, RowId x) {

    }

    @Override
    public void updateRowId(String columnLabel, RowId x) {

    }

    @Override
    public RowId getRowId(int columnIndex) {
        return null;
    }

    @Override
    public RowId getRowId(String columnLabel) {
        return null;
    }

    @Override
    public boolean isWrapperFor(Class<?> iface) {
        return false;
    }

    @Override
    public <T> T unwrap(Class<T> iface) {
        return null;
    }
}

